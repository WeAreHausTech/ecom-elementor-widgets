!// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
function(e,t,r,n,o){/* eslint-disable no-undef */var l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},i="function"==typeof l[n]&&l[n],a=i.cache||{},s="undefined"!=typeof module&&"function"==typeof module.require&&module.require.bind(module);function c(t,r){if(!a[t]){if(!e[t]){// if we cannot find the module within our internal map or
// cache jump to the current global require ie. the last bundle
// that was added to the page.
var o="function"==typeof l[n]&&l[n];if(!r&&o)return o(t,!0);// If there are other bundles on this page the require from the
// previous one is saved to 'previousRequire'. Repeat this as
// many times as there are bundles until the module is found or
// we exhaust the require chain.
if(i)return i(t,!0);// Try the node require function if it exists.
if(s&&"string"==typeof t)return s(t);var u=Error("Cannot find module '"+t+"'");throw u.code="MODULE_NOT_FOUND",u}f.resolve=function(r){var n=e[t][1][r];return null!=n?n:r},f.cache={};var d=a[t]=new c.Module(t);e[t][0].call(d.exports,f,d,d.exports,this)}return a[t].exports;function f(e){var t=f.resolve(e);return!1===t?{}:c(t)}}c.isParcelRequire=!0,c.Module=function(e){this.id=e,this.bundle=c,this.exports={}},c.modules=e,c.cache=a,c.parent=i,c.register=function(t,r){e[t]=[function(e,t){t.exports=r},{}]},Object.defineProperty(c,"root",{get:function(){return l[n]}}),l[n]=c;for(var u=0;u<t.length;u++)c(t[u]);if(r){// Expose entry point to Node, AMD or browser globals
// Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
var d=c(r);// CommonJS
"object"==typeof exports&&"undefined"!=typeof module?module.exports=d:"function"==typeof define&&define.amd?define(function(){return d}):o&&(this[o]=d)}}({"4nsuJ":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"ProductList",()=>u);var o=e("react/jsx-runtime"),l=e("@haus-tech/ecom-components"),i=e("../button/Button"),a=e("../select/Select");let s=({product:e,facetValues:t})=>/*#__PURE__*/(0,o.jsxs)("a",{className:"product-list-product-card",href:`/products/${e.slug}`,children:[/*#__PURE__*/(0,o.jsx)("div",{className:"product-image-wrapper",children:/*#__PURE__*/(0,o.jsx)("img",{src:e.productAsset?.preview,alt:e.productName,className:"product-image"})}),/*#__PURE__*/(0,o.jsxs)("div",{className:"product-info",children:[/*#__PURE__*/(0,o.jsx)("div",{className:"product-brand",children:(t=>{let{facetValueIds:r}=e,n=t.brand;if(!n)return null;let o=n.find(e=>r.includes(e.id));return o?o.name:null})(t||"")}),/*#__PURE__*/(0,o.jsx)("div",{className:"product-name",children:e.productName}),/*#__PURE__*/(0,o.jsx)(l.Price,{className:"product-price",price:e.price,priceWithTax:e.priceWithTax,currencyCode:e.currencyCode,children:({formattedPrice:e})=>/*#__PURE__*/(0,o.jsx)(o.Fragment,{children:e})})]})]}),c=({pagination:e})=>{if(!e)return null;let{itemsPerPage:t,currentPage:r,totalPages:n,totalItems:l,canGoForward:a,nextPage:s}=e;return/*#__PURE__*/(0,o.jsxs)("div",{className:"product-list-pagination",children:[/*#__PURE__*/(0,o.jsxs)("div",{children:["Visar ",t*r>l?l:t*r," av ",l]}),/*#__PURE__*/(0,o.jsx)("div",{className:"pagination-progress",children:/*#__PURE__*/(0,o.jsx)("div",{className:"pagination-progress-bar",style:{width:`${r/n*100}%`}})}),/*#__PURE__*/(0,o.jsx)("div",{className:"pagination-buttons",children:/*#__PURE__*/(0,o.jsx)(i.Button,{className:"load-more-button",color:"white",disabled:!a,onClick:s,children:"Visa mer"})})]})},u=({searchInputProps:e,availableSortOptions:t=d})=>/*#__PURE__*/(0,o.jsx)(l.ProductList,{className:"ProductList",infinitePagination:!0,searchInputProps:e,children:({loading:e,products:r,facetValues:n,pagination:l,filters:i,error:u})=>e&&0===r.length?/*#__PURE__*/(0,o.jsx)("div",{children:"Loading..."}):u?/*#__PURE__*/(0,o.jsx)("div",{children:"Error"}):r.length?/*#__PURE__*/(0,o.jsxs)(o.Fragment,{children:[/*#__PURE__*/(0,o.jsx)("div",{className:"product-list-sort",children:/*#__PURE__*/(0,o.jsx)(a.Select,{options:t,defaultValue:JSON.stringify(i?.sort),onValueChange:e=>i?.setSort(JSON.parse(e)),triggerProps:{color:"blue",rounded:"full"}})}),r.map(e=>/*#__PURE__*/(0,o.jsx)(s,{product:e,facetValues:n},e.productId)),/*#__PURE__*/(0,o.jsx)(c,{pagination:l})]}):/*#__PURE__*/(0,o.jsx)("div",{children:"Inga produkter hittades"})}),d=[{label:"Namn",value:{name:l.SortOrder.Asc}},{label:"Pris fallande",value:{price:l.SortOrder.Desc}},{label:"Pris stigande",value:{price:l.SortOrder.Asc}}];r.default=u},{"react/jsx-runtime":"gaGEj","@haus-tech/ecom-components":"gfPld","../button/Button":"lm4gx","../select/Select":"j1p25","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],lm4gx:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"Button",()=>a);var o=e("classnames"),l=n.interopDefault(o),i=e("react");let a=/*#__PURE__*/(0,i.forwardRef)(({children:e,color:t,variant:r,rounded:n,className:o,...a},s)=>/*#__PURE__*/(0,i.createElement)("button",{...Object.assign({className:(0,l.default)("Button",o,t,r,n)},a),ref:s},e))},{classnames:"hVGzI",react:"6uln9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],hVGzI:[function(e,t,r){!/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*//* global define */function(){var e={}.hasOwnProperty;function r(){for(var t=[],n=0;n<arguments.length;n++){var o=arguments[n];if(o){var l=typeof o;if("string"===l||"number"===l)t.push(o);else if(Array.isArray(o)){if(o.length){var i=r.apply(null,o);i&&t.push(i)}}else if("object"===l){if(o.toString!==Object.prototype.toString&&!o.toString.toString().includes("[native code]")){t.push(o.toString());continue}for(var a in o)e.call(o,a)&&o[a]&&t.push(a)}}}return t.join(" ")}t.exports?(r.default=r,t.exports=r):"function"==typeof define&&"object"==typeof define.amd&&define.amd?define("classnames",[],function(){return r}):window.classNames=r}()},{}],j1p25:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"Select",()=>d);var o=e("react/jsx-runtime"),l=e("@radix-ui/react-select"),i=e("classnames"),a=n.interopDefault(i),s=e("react"),c=e("../icon/Icon"),u=e("../button/Button");let d=({options:e,defaultValue:t,onValueChange:r,triggerProps:n,...i})=>/*#__PURE__*/(0,o.jsxs)(l.Root,{defaultValue:t,onValueChange:r,...i,children:[/*#__PURE__*/(0,o.jsx)(l.Trigger,{className:"SelectTrigger","aria-label":"Select",asChild:!0,children:/*#__PURE__*/(0,o.jsxs)(u.Button,{...n,children:[/*#__PURE__*/(0,o.jsx)(l.Value,{placeholder:"Selectâ€¦"}),/*#__PURE__*/(0,o.jsx)(l.Icon,{className:"SelectIcon",children:/*#__PURE__*/(0,o.jsx)(c.Icon,{name:"chevron-down"})})]})}),/*#__PURE__*/(0,o.jsxs)(l.Content,{className:"SelectContent",position:"popper",sideOffset:8,children:[/*#__PURE__*/(0,o.jsx)(l.ScrollUpButton,{className:"SelectScrollButton",children:/*#__PURE__*/(0,o.jsx)(c.Icon,{name:"chevron-up"})}),/*#__PURE__*/(0,o.jsx)(l.Viewport,{className:"SelectViewport",children:e.map((e,t)=>/*#__PURE__*/(0,o.jsx)(f,{value:"string"==typeof e.value?e.value:JSON.stringify(e.value),children:e.label},t))}),/*#__PURE__*/(0,o.jsx)(l.ScrollDownButton,{className:"SelectScrollButton",children:/*#__PURE__*/(0,o.jsx)(c.Icon,{name:"chevron-down"})})]})]}),f=/*#__PURE__*/(0,s.forwardRef)(({children:e,className:t,value:r,...n},i)=>/*#__PURE__*/(0,o.jsxs)(l.Item,{className:(0,a.default)("SelectItem",t),value:r,...n,ref:i,children:[/*#__PURE__*/(0,o.jsx)(l.ItemText,{children:e}),/*#__PURE__*/(0,o.jsx)(l.ItemIndicator,{className:"SelectItemIndicator",children:/*#__PURE__*/(0,o.jsx)(c.Icon,{name:"check"})})]}))},{"react/jsx-runtime":"gaGEj","@radix-ui/react-select":"3xkyn",classnames:"hVGzI",react:"6uln9","../icon/Icon":"dRKtt","../button/Button":"lm4gx","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"3xkyn":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"createSelectScope",()=>D),n.export(r,"Select",()=>V),n.export(r,"SelectTrigger",()=>z),n.export(r,"SelectValue",()=>G),n.export(r,"SelectIcon",()=>K),n.export(r,"SelectPortal",()=>U),n.export(r,"SelectContent",()=>Y),n.export(r,"SelectViewport",()=>en),n.export(r,"SelectGroup",()=>ei),n.export(r,"SelectLabel",()=>ea),n.export(r,"SelectItem",()=>ed),n.export(r,"SelectItemText",()=>ep),n.export(r,"SelectItemIndicator",()=>em),n.export(r,"SelectScrollUpButton",()=>ev),n.export(r,"SelectScrollDownButton",()=>ex),n.export(r,"SelectSeparator",()=>eb),n.export(r,"SelectArrow",()=>eS),n.export(r,"Root",()=>eR),n.export(r,"Trigger",()=>eP),n.export(r,"Value",()=>e_),n.export(r,"Icon",()=>ek),n.export(r,"Portal",()=>eT),n.export(r,"Content",()=>eI),n.export(r,"Viewport",()=>eO),n.export(r,"Group",()=>eA),n.export(r,"Label",()=>eL),n.export(r,"Item",()=>eN),n.export(r,"ItemText",()=>eD),n.export(r,"ItemIndicator",()=>eF),n.export(r,"ScrollUpButton",()=>eM),n.export(r,"ScrollDownButton",()=>eB),n.export(r,"Separator",()=>eH),n.export(r,"Arrow",()=>eW);var o=e("@babel/runtime/helpers/esm/extends"),l=n.interopDefault(o),i=e("react"),a=e("react-dom"),s=e("@radix-ui/number"),c=e("@radix-ui/primitive"),u=e("@radix-ui/react-collection"),d=e("@radix-ui/react-compose-refs"),f=e("@radix-ui/react-context"),p=e("@radix-ui/react-direction"),m=e("@radix-ui/react-dismissable-layer"),h=e("@radix-ui/react-focus-guards"),v=e("@radix-ui/react-focus-scope"),g=e("@radix-ui/react-id"),x=e("@radix-ui/react-popper"),y=e("@radix-ui/react-portal"),b=e("@radix-ui/react-primitive"),w=e("@radix-ui/react-slot"),S=e("@radix-ui/react-use-callback-ref"),E=e("@radix-ui/react-use-controllable-state"),j=e("@radix-ui/react-use-layout-effect"),C=e("@radix-ui/react-use-previous"),R=e("@radix-ui/react-visually-hidden"),P=e("aria-hidden"),_=e("react-remove-scroll");let k=[" ","Enter","ArrowUp","ArrowDown"],T=[" ","Enter"],I="Select",[O,A,L]=(0,u.createCollection)(I),[N,D]=(0,f.createContextScope)(I,[L,x.createPopperScope]),F=(0,x.createPopperScope)(),[M,B]=N(I),[H,W]=N(I),V=e=>{let{__scopeSelect:t,children:r,open:n,defaultOpen:o,onOpenChange:l,value:a,defaultValue:s,onValueChange:c,dir:u,name:d,autoComplete:f,disabled:m,required:h}=e,v=F(t),[y,b]=(0,i.useState)(null),[w,S]=(0,i.useState)(null),[j,C]=(0,i.useState)(!1),R=(0,p.useDirection)(u),[P=!1,_]=(0,E.useControllableState)({prop:n,defaultProp:o,onChange:l}),[k,T]=(0,E.useControllableState)({prop:a,defaultProp:s,onChange:c}),I=(0,i.useRef)(null),A=!y||!!y.closest("form"),[L,N]=(0,i.useState)(new Set),D=Array.from(L).map(e=>e.props.value).join(";");return/*#__PURE__*/(0,i.createElement)(x.Root,v,/*#__PURE__*/(0,i.createElement)(M,{required:h,scope:t,trigger:y,onTriggerChange:b,valueNode:w,onValueNodeChange:S,valueNodeHasChildren:j,onValueNodeHasChildrenChange:C,contentId:(0,g.useId)(),value:k,onValueChange:T,open:P,onOpenChange:_,dir:R,triggerPointerDownPosRef:I,disabled:m},/*#__PURE__*/(0,i.createElement)(O.Provider,{scope:t},/*#__PURE__*/(0,i.createElement)(H,{scope:e.__scopeSelect,onNativeOptionAdd:(0,i.useCallback)(e=>{N(t=>new Set(t).add(e))},[]),onNativeOptionRemove:(0,i.useCallback)(e=>{N(t=>{let r=new Set(t);return r.delete(e),r})},[])},r)),A?/*#__PURE__*/(0,i.createElement)(eE,{key:D,"aria-hidden":!0,required:h,tabIndex:-1,name:d,autoComplete:f,value:k// enable form autofill
,onChange:e=>T(e.target.value),disabled:m},void 0===k?/*#__PURE__*/(0,i.createElement)("option",{value:""}):null,Array.from(L)):null))},z=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,disabled:n=!1,...o}=e,a=F(r),s=B("SelectTrigger",r),u=s.disabled||n,f=(0,d.useComposedRefs)(t,s.onTriggerChange),p=A(r),[m,h,v]=ej(e=>{let t=p().filter(e=>!e.disabled),r=t.find(e=>e.value===s.value),n=eC(t,e,r);void 0!==n&&s.onValueChange(n.value)}),g=()=>{u||(s.onOpenChange(!0),v())};return/*#__PURE__*/(0,i.createElement)(x.Anchor,(0,l.default)({asChild:!0},a),/*#__PURE__*/(0,i.createElement)(b.Primitive.button,(0,l.default)({type:"button",role:"combobox","aria-controls":s.contentId,"aria-expanded":s.open,"aria-required":s.required,"aria-autocomplete":"none",dir:s.dir,"data-state":s.open?"open":"closed",disabled:u,"data-disabled":u?"":void 0,"data-placeholder":void 0===s.value?"":void 0},o,{ref:f// Enable compatibility with native label or custom `Label` "click" for Safari:
,onClick:(0,c.composeEventHandlers)(o.onClick,e=>{// Whilst browsers generally have no issue focusing the trigger when clicking
// on a label, Safari seems to struggle with the fact that there's no `onClick`.
// We force `focus` in this case. Note: this doesn't create any other side-effect
// because we are preventing default in `onPointerDown` so effectively
// this only runs for a label "click"
e.currentTarget.focus()}),onPointerDown:(0,c.composeEventHandlers)(o.onPointerDown,e=>{// prevent implicit pointer capture
// https://www.w3.org/TR/pointerevents3/#implicit-pointer-capture
let t=e.target;t.hasPointerCapture(e.pointerId)&&t.releasePointerCapture(e.pointerId),0===e.button&&!1===e.ctrlKey&&(g(),s.triggerPointerDownPosRef.current={x:Math.round(e.pageX),y:Math.round(e.pageY)},e.preventDefault())}),onKeyDown:(0,c.composeEventHandlers)(o.onKeyDown,e=>{let t=""!==m.current,r=e.ctrlKey||e.altKey||e.metaKey;r||1!==e.key.length||h(e.key),(!t||" "!==e.key)&&k.includes(e.key)&&(g(),e.preventDefault())})})))}),G=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{// We ignore `className` and `style` as this part shouldn't be styled.
let{__scopeSelect:r,className:n,style:o,children:a,placeholder:s,...c}=e,u=B("SelectValue",r),{onValueNodeHasChildrenChange:f}=u,p=void 0!==a,m=(0,d.useComposedRefs)(t,u.onValueNodeChange);return(0,j.useLayoutEffect)(()=>{f(p)},[f,p]),/*#__PURE__*/(0,i.createElement)(b.Primitive.span,(0,l.default)({},c,{ref:m// we don't want events from the portalled `SelectValue` children to bubble
,style:{pointerEvents:"none"}}),void 0===u.value&&void 0!==s?s:a)}),K=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,children:n,...o}=e;return/*#__PURE__*/(0,i.createElement)(b.Primitive.span,(0,l.default)({"aria-hidden":!0},o,{ref:t}),n||"â–¼")}),U=e=>/*#__PURE__*/(0,i.createElement)(y.Portal,(0,l.default)({asChild:!0},e)),X="SelectContent",Y=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let r=B(X,e.__scopeSelect),[n,o]=(0,i.useState)();return((0,j.useLayoutEffect)(()=>{o(new DocumentFragment)},[]),r.open)?/*#__PURE__*/(0,i.createElement)(q,(0,l.default)({},e,{ref:t})):n?/*#__PURE__*/(0,a.createPortal)(/*#__PURE__*/(0,i.createElement)($,{scope:e.__scopeSelect},/*#__PURE__*/(0,i.createElement)(O.Slot,{scope:e.__scopeSelect},/*#__PURE__*/(0,i.createElement)("div",null,e.children))),n):null}),[$,J]=N(X),q=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,position:n="item-aligned",onCloseAutoFocus:o,onEscapeKeyDown:a,onPointerDownOutside:s,side:u,sideOffset:f,align:p,alignOffset:g,arrowPadding:x,collisionBoundary:y,collisionPadding:b,sticky:S,hideWhenDetached:E,avoidCollisions:j,...C}=e,R=B(X,r),[k,T]=(0,i.useState)(null),[I,O]=(0,i.useState)(null),L=(0,d.useComposedRefs)(t,e=>T(e)),[N,D]=(0,i.useState)(null),[F,M]=(0,i.useState)(null),H=A(r),[W,V]=(0,i.useState)(!1),z=(0,i.useRef)(!1);(0,i.useEffect)(()=>{if(k)return(0,P.hideOthers)(k)},[k]),// the last element in the DOM (because of the `Portal`)
(0,h.useFocusGuards)();let G=(0,i.useCallback)(e=>{let[t,...r]=H().map(e=>e.ref.current),[n]=r.slice(-1),o=document.activeElement;for(let r of e)// if focus is already where we want to go, we don't want to keep going through the candidates
if(r===o||(null==r||r.scrollIntoView({block:"nearest"}),r===t&&I&&(I.scrollTop=0),r===n&&I&&(I.scrollTop=I.scrollHeight),null==r||r.focus(),document.activeElement!==o))return},[H,I]),K=(0,i.useCallback)(()=>G([N,k]),[G,N,k]);// other effects across components. Hence why we don't call `focusSelectedItem` inside `position`.
(0,i.useEffect)(()=>{W&&K()},[W,K]);// and close on `pointerup` outside.
let{onOpenChange:U,triggerPointerDownPosRef:Y}=R;(0,i.useEffect)(()=>{if(k){let e={x:0,y:0},t=t=>{var r,n,o,l;e={x:Math.abs(Math.round(t.pageX)-(null!==(r=null===(n=Y.current)||void 0===n?void 0:n.x)&&void 0!==r?r:0)),y:Math.abs(Math.round(t.pageY)-(null!==(o=null===(l=Y.current)||void 0===l?void 0:l.y)&&void 0!==o?o:0))}},r=r=>{e.x<=10&&e.y<=10?r.preventDefault():k.contains(r.target)||U(!1),document.removeEventListener("pointermove",t),Y.current=null};return null!==Y.current&&(document.addEventListener("pointermove",t),document.addEventListener("pointerup",r,{capture:!0,once:!0})),()=>{document.removeEventListener("pointermove",t),document.removeEventListener("pointerup",r,{capture:!0})}}},[k,U,Y]),(0,i.useEffect)(()=>{let e=()=>U(!1);return window.addEventListener("blur",e),window.addEventListener("resize",e),()=>{window.removeEventListener("blur",e),window.removeEventListener("resize",e)}},[U]);let[J,q]=ej(e=>{let t=H().filter(e=>!e.disabled),r=t.find(e=>e.ref.current===document.activeElement),n=eC(t,e,r);n&&/**
       * Imperative focus during keydown is risky so we prevent React's batching updates
       * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332
       */setTimeout(()=>n.ref.current.focus())}),ee=(0,i.useCallback)((e,t,r)=>{let n=!z.current&&!r,o=void 0!==R.value&&R.value===t;(o||n)&&(D(e),n&&(z.current=!0))},[R.value]),et=(0,i.useCallback)(()=>null==k?void 0:k.focus(),[k]),er=(0,i.useCallback)((e,t,r)=>{let n=!z.current&&!r,o=void 0!==R.value&&R.value===t;(o||n)&&M(e)},[R.value]),en="popper"===n?Q:Z,eo=en===Q?{side:u,sideOffset:f,align:p,alignOffset:g,arrowPadding:x,collisionBoundary:y,collisionPadding:b,sticky:S,hideWhenDetached:E,avoidCollisions:j}:{};return/*#__PURE__*/(0,i.createElement)($,{scope:r,content:k,viewport:I,onViewportChange:O,itemRefCallback:ee,selectedItem:N,onItemLeave:et,itemTextRefCallback:er,focusSelectedItem:K,selectedItemText:F,position:n,isPositioned:W,searchRef:J},/*#__PURE__*/(0,i.createElement)(_.RemoveScroll,{as:w.Slot,allowPinchZoom:!0},/*#__PURE__*/(0,i.createElement)(v.FocusScope,{asChild:!0// we make sure we're not trapping once it's been closed
,trapped:R.open,onMountAutoFocus:e=>{// we prevent open autofocus because we manually focus the selected item
e.preventDefault()},onUnmountAutoFocus:(0,c.composeEventHandlers)(o,e=>{var t;null===(t=R.trigger)||void 0===t||t.focus({preventScroll:!0}),e.preventDefault()})},/*#__PURE__*/(0,i.createElement)(m.DismissableLayer,{asChild:!0,disableOutsidePointerEvents:!0,onEscapeKeyDown:a,onPointerDownOutside:s// When focus is trapped, a focusout event may still happen.
,onFocusOutside:e=>e.preventDefault(),onDismiss:()=>R.onOpenChange(!1)},/*#__PURE__*/(0,i.createElement)(en,(0,l.default)({role:"listbox",id:R.contentId,"data-state":R.open?"open":"closed",dir:R.dir,onContextMenu:e=>e.preventDefault()},C,eo,{onPlaced:()=>V(!0),ref:L,style:{// flex layout so we can place the scroll buttons properly
display:"flex",flexDirection:"column",// reset the outline by default as the content MAY get focused
outline:"none",...C.style},onKeyDown:(0,c.composeEventHandlers)(C.onKeyDown,e=>{let t=e.ctrlKey||e.altKey||e.metaKey;// select should not be navigated using tab key so we prevent it
if("Tab"===e.key&&e.preventDefault(),t||1!==e.key.length||q(e.key),["ArrowUp","ArrowDown","Home","End"].includes(e.key)){let t=H().filter(e=>!e.disabled),r=t.map(e=>e.ref.current);if(["ArrowUp","End"].includes(e.key)&&(r=r.slice().reverse()),["ArrowUp","ArrowDown"].includes(e.key)){let t=e.target,n=r.indexOf(t);r=r.slice(n+1)}/**
         * Imperative focus during keydown is risky so we prevent React's batching updates
         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332
         */setTimeout(()=>G(r)),e.preventDefault()}})}))))))}),Z=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,onPlaced:n,...o}=e,a=B(X,r),c=J(X,r),[u,f]=(0,i.useState)(null),[p,m]=(0,i.useState)(null),h=(0,d.useComposedRefs)(t,e=>m(e)),v=A(r),g=(0,i.useRef)(!1),x=(0,i.useRef)(!0),{viewport:y,selectedItem:w,selectedItemText:S,focusSelectedItem:E}=c,C=(0,i.useCallback)(()=>{if(a.trigger&&a.valueNode&&u&&p&&y&&w&&S){let e=a.trigger.getBoundingClientRect(),t=p.getBoundingClientRect(),r=a.valueNode.getBoundingClientRect(),o=S.getBoundingClientRect();// -----------------------------------------------------------------------------------------
if("rtl"!==a.dir){let n=o.left-t.left,l=r.left-n,i=e.left-l,a=e.width+i,c=Math.max(a,t.width),d=window.innerWidth-10,f=(0,s.clamp)(l,[10,d-c]);u.style.minWidth=a+"px",u.style.left=f+"px"}else{let n=t.right-o.right,l=window.innerWidth-r.right-n,i=window.innerWidth-e.right-l,a=e.width+i,c=Math.max(a,t.width),d=window.innerWidth-10,f=(0,s.clamp)(l,[10,d-c]);u.style.minWidth=a+"px",u.style.right=f+"px"}// -----------------------------------------------------------------------------------------
// Vertical positioning
// -----------------------------------------------------------------------------------------
let l=v(),i=window.innerHeight-20,c=y.scrollHeight,d=window.getComputedStyle(p),f=parseInt(d.borderTopWidth,10),m=parseInt(d.paddingTop,10),h=parseInt(d.borderBottomWidth,10),x=parseInt(d.paddingBottom,10),b=f+m+c+x+h,E=Math.min(5*w.offsetHeight,b),j=window.getComputedStyle(y),C=parseInt(j.paddingTop,10),R=parseInt(j.paddingBottom,10),P=e.top+e.height/2-10,_=w.offsetHeight/2,k=w.offsetTop+_,T=f+m+k;if(T<=P){let e=w===l[l.length-1].ref.current;u.style.bottom="0px";let t=p.clientHeight-y.offsetTop-y.offsetHeight;u.style.height=T+Math.max(i-P,_+(e?R:0)+t+h)+"px"}else{let e=w===l[0].ref.current;u.style.top="0px";let t=Math.max(P,f+y.offsetTop+(e?C:0)+_);u.style.height=t+(b-T)+"px",y.scrollTop=T-P+y.offsetTop}u.style.margin="10px 0",u.style.minHeight=E+"px",u.style.maxHeight=i+"px",null==n||n(),// so we explicitly turn it on only after they've registered.
requestAnimationFrame(()=>g.current=!0)}},[v,a.trigger,a.valueNode,u,p,y,w,S,a.dir,n]);(0,j.useLayoutEffect)(()=>C(),[C]);// copy z-index from content to wrapper
let[R,P]=(0,i.useState)();(0,j.useLayoutEffect)(()=>{p&&P(window.getComputedStyle(p).zIndex)},[p]);// When the viewport becomes scrollable at the top, the scroll up button will mount.
// Because it is part of the normal flow, it will push down the viewport, thus throwing our
// trigger => selectedItem alignment off by the amount the viewport was pushed down.
// We wait for this to happen and then re-run the positining logic one more time to account for it.
let _=(0,i.useCallback)(e=>{e&&!0===x.current&&(C(),null==E||E(),x.current=!1)},[C,E]);return/*#__PURE__*/(0,i.createElement)(ee,{scope:r,contentWrapper:u,shouldExpandOnScrollRef:g,onScrollButtonChange:_},/*#__PURE__*/(0,i.createElement)("div",{ref:f,style:{display:"flex",flexDirection:"column",position:"fixed",zIndex:R}},/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({},o,{ref:h,style:{// When we get the height of the content, it includes borders. If we were to set
// the height without having `boxSizing: 'border-box'` it would be too big.
boxSizing:"border-box",// We need to ensure the content doesn't get taller than the wrapper
maxHeight:"100%",...o.style}}))))}),Q=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,align:n="start",collisionPadding:o=10,...a}=e,s=F(r);return/*#__PURE__*/(0,i.createElement)(x.Content,(0,l.default)({},s,a,{ref:t,align:n,collisionPadding:o,style:{// Ensure border-box for floating-ui calculations
boxSizing:"border-box",...a.style,"--radix-select-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-select-content-available-width":"var(--radix-popper-available-width)","--radix-select-content-available-height":"var(--radix-popper-available-height)","--radix-select-trigger-width":"var(--radix-popper-anchor-width)","--radix-select-trigger-height":"var(--radix-popper-anchor-height)"}}))}),[ee,et]=N(X,{}),er="SelectViewport",en=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e,o=J(er,r),a=et(er,r),s=(0,d.useComposedRefs)(t,o.onViewportChange),u=(0,i.useRef)(0);return/*#__PURE__*/(0,i.createElement)(i.Fragment,null,/*#__PURE__*/(0,i.createElement)("style",{dangerouslySetInnerHTML:{__html:"[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"}}),/*#__PURE__*/(0,i.createElement)(O.Slot,{scope:r},/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({"data-radix-select-viewport":"",role:"presentation"},n,{ref:s,style:{// we use position: 'relative' here on the `viewport` so that when we call
// `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
// (independent of the scrollUpButton).
position:"relative",flex:1,overflow:"auto",...n.style},onScroll:(0,c.composeEventHandlers)(n.onScroll,e=>{let t=e.currentTarget,{contentWrapper:r,shouldExpandOnScrollRef:n}=a;if(null!=n&&n.current&&r){let e=Math.abs(u.current-t.scrollTop);if(e>0){let n=window.innerHeight-20,o=parseFloat(r.style.minHeight),l=parseFloat(r.style.height),i=Math.max(o,l);if(i<n){let o=i+e,l=Math.min(n,o),a=o-l;r.style.height=l+"px","0px"===r.style.bottom&&(t.scrollTop=a>0?a:0,r.style.justifyContent="flex-end")}}}u.current=t.scrollTop})}))))}),[eo,el]=N("SelectGroup"),ei=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e,o=(0,g.useId)();return/*#__PURE__*/(0,i.createElement)(eo,{scope:r,id:o},/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({role:"group","aria-labelledby":o},n,{ref:t})))}),ea=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e,o=el("SelectLabel",r);return/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({id:o.id},n,{ref:t}))}),es="SelectItem",[ec,eu]=N(es),ed=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,value:n,disabled:o=!1,textValue:a,...s}=e,u=B(es,r),f=J(es,r),p=u.value===n,[m,h]=(0,i.useState)(null!=a?a:""),[v,x]=(0,i.useState)(!1),y=(0,d.useComposedRefs)(t,e=>{var t;return null===(t=f.itemRefCallback)||void 0===t?void 0:t.call(f,e,n,o)}),w=(0,g.useId)(),S=()=>{o||(u.onValueChange(n),u.onOpenChange(!1))};return/*#__PURE__*/(0,i.createElement)(ec,{scope:r,value:n,disabled:o,textId:w,isSelected:p,onItemTextChange:(0,i.useCallback)(e=>{h(t=>{var r;return t||(null!==(r=null==e?void 0:e.textContent)&&void 0!==r?r:"").trim()})},[])},/*#__PURE__*/(0,i.createElement)(O.ItemSlot,{scope:r,value:n,disabled:o,textValue:m},/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({role:"option","aria-labelledby":w,"data-highlighted":v?"":void 0// `isFocused` caveat fixes stuttering in VoiceOver
,"aria-selected":p&&v,"data-state":p?"checked":"unchecked","aria-disabled":o||void 0,"data-disabled":o?"":void 0,tabIndex:o?void 0:-1},s,{ref:y,onFocus:(0,c.composeEventHandlers)(s.onFocus,()=>x(!0)),onBlur:(0,c.composeEventHandlers)(s.onBlur,()=>x(!1)),onPointerUp:(0,c.composeEventHandlers)(s.onPointerUp,S),onPointerMove:(0,c.composeEventHandlers)(s.onPointerMove,e=>{if(o){var t;null===(t=f.onItemLeave)||void 0===t||t.call(f)}else e.currentTarget.focus({preventScroll:!0})}),onPointerLeave:(0,c.composeEventHandlers)(s.onPointerLeave,e=>{if(e.currentTarget===document.activeElement){var t;null===(t=f.onItemLeave)||void 0===t||t.call(f)}}),onKeyDown:(0,c.composeEventHandlers)(s.onKeyDown,e=>{var t;let r=(null===(t=f.searchRef)||void 0===t?void 0:t.current)!=="";r&&" "===e.key||(T.includes(e.key)&&S()," "===e.key&&e.preventDefault())})}))))}),ef="SelectItemText",ep=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{// We ignore `className` and `style` as this part shouldn't be styled.
let{__scopeSelect:r,className:n,style:o,...s}=e,c=B(ef,r),u=J(ef,r),f=eu(ef,r),p=W(ef,r),[m,h]=(0,i.useState)(null),v=(0,d.useComposedRefs)(t,e=>h(e),f.onItemTextChange,e=>{var t;return null===(t=u.itemTextRefCallback)||void 0===t?void 0:t.call(u,e,f.value,f.disabled)}),g=null==m?void 0:m.textContent,x=(0,i.useMemo)(()=>/*#__PURE__*/(0,i.createElement)("option",{key:f.value,value:f.value,disabled:f.disabled},g),[f.disabled,f.value,g]),{onNativeOptionAdd:y,onNativeOptionRemove:w}=p;return(0,j.useLayoutEffect)(()=>(y(x),()=>w(x)),[y,w,x]),/*#__PURE__*/(0,i.createElement)(i.Fragment,null,/*#__PURE__*/(0,i.createElement)(b.Primitive.span,(0,l.default)({id:f.textId},s,{ref:v})),f.isSelected&&c.valueNode&&!c.valueNodeHasChildren?/*#__PURE__*/(0,a.createPortal)(s.children,c.valueNode):null)}),em=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e,o=eu("SelectItemIndicator",r);return o.isSelected?/*#__PURE__*/(0,i.createElement)(b.Primitive.span,(0,l.default)({"aria-hidden":!0},n,{ref:t})):null}),eh="SelectScrollUpButton",ev=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let r=J(eh,e.__scopeSelect),n=et(eh,e.__scopeSelect),[o,a]=(0,i.useState)(!1),s=(0,d.useComposedRefs)(t,n.onScrollButtonChange);return(0,j.useLayoutEffect)(()=>{if(r.viewport&&r.isPositioned){let t=r.viewport;function e(){let e=t.scrollTop>0;a(e)}return e(),t.addEventListener("scroll",e),()=>t.removeEventListener("scroll",e)}},[r.viewport,r.isPositioned]),o?/*#__PURE__*/(0,i.createElement)(ey,(0,l.default)({},e,{ref:s,onAutoScroll:()=>{let{viewport:e,selectedItem:t}=r;e&&t&&(e.scrollTop=e.scrollTop-t.offsetHeight)}})):null}),eg="SelectScrollDownButton",ex=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let r=J(eg,e.__scopeSelect),n=et(eg,e.__scopeSelect),[o,a]=(0,i.useState)(!1),s=(0,d.useComposedRefs)(t,n.onScrollButtonChange);return(0,j.useLayoutEffect)(()=>{if(r.viewport&&r.isPositioned){let t=r.viewport;function e(){let e=t.scrollHeight-t.clientHeight,r=Math.ceil(t.scrollTop)<e;// we use Math.ceil here because if the UI is zoomed-in
a(r)}return e(),t.addEventListener("scroll",e),()=>t.removeEventListener("scroll",e)}},[r.viewport,r.isPositioned]),o?/*#__PURE__*/(0,i.createElement)(ey,(0,l.default)({},e,{ref:s,onAutoScroll:()=>{let{viewport:e,selectedItem:t}=r;e&&t&&(e.scrollTop=e.scrollTop+t.offsetHeight)}})):null}),ey=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,onAutoScroll:n,...o}=e,a=J("SelectScrollButton",r),s=(0,i.useRef)(null),u=A(r),d=(0,i.useCallback)(()=>{null!==s.current&&(window.clearInterval(s.current),s.current=null)},[]);return(0,i.useEffect)(()=>()=>d(),[d]),// Because it is part of the normal flow, it will push down (top button) or shrink (bottom button)
// the viewport, potentially causing the active item to now be partially out of view.
// We re-run the `scrollIntoView` logic to make sure it stays within the viewport.
(0,j.useLayoutEffect)(()=>{var e;let t=u().find(e=>e.ref.current===document.activeElement);null==t||null===(e=t.ref.current)||void 0===e||e.scrollIntoView({block:"nearest"})},[u]),/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({"aria-hidden":!0},o,{ref:t,style:{flexShrink:0,...o.style},onPointerDown:(0,c.composeEventHandlers)(o.onPointerDown,()=>{null===s.current&&(s.current=window.setInterval(n,50))}),onPointerMove:(0,c.composeEventHandlers)(o.onPointerMove,()=>{var e;null===(e=a.onItemLeave)||void 0===e||e.call(a),null===s.current&&(s.current=window.setInterval(n,50))}),onPointerLeave:(0,c.composeEventHandlers)(o.onPointerLeave,()=>{d()})}))}),eb=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e;return/*#__PURE__*/(0,i.createElement)(b.Primitive.div,(0,l.default)({"aria-hidden":!0},n,{ref:t}))}),ew="SelectArrow",eS=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopeSelect:r,...n}=e,o=F(r),a=B(ew,r),s=J(ew,r);return a.open&&"popper"===s.position?/*#__PURE__*/(0,i.createElement)(x.Arrow,(0,l.default)({},o,n,{ref:t})):null}),eE=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{value:r,...n}=e,o=(0,i.useRef)(null),a=(0,d.useComposedRefs)(t,o),s=(0,C.usePrevious)(r);/**
   * We purposefully use a `select` here to support form autofill as much
   * as possible.
   *
   * We purposefully do not add the `value` attribute here to allow the value
   * to be set programatically and bubble to any parent form `onChange` event.
   * Adding the `value` will cause React to consider the programatic
   * dispatch a duplicate and it will get swallowed.
   *
   * We use `VisuallyHidden` rather than `display: "none"` because Safari autofill
   * won't work otherwise.
   */return(0,i.useEffect)(()=>{let e=o.current,t=window.HTMLSelectElement.prototype,n=Object.getOwnPropertyDescriptor(t,"value"),l=n.set;if(s!==r&&l){let t=new Event("change",{bubbles:!0});l.call(e,r),e.dispatchEvent(t)}},[s,r]),/*#__PURE__*/(0,i.createElement)(R.VisuallyHidden,{asChild:!0},/*#__PURE__*/(0,i.createElement)("select",(0,l.default)({},n,{ref:a,defaultValue:r})))});function ej(e){let t=(0,S.useCallbackRef)(e),r=(0,i.useRef)(""),n=(0,i.useRef)(0),o=(0,i.useCallback)(e=>{let o=r.current+e;t(o),function e(t){r.current=t,window.clearTimeout(n.current),""!==t&&(n.current=window.setTimeout(()=>e(""),1e3))}(o)},[t]),l=(0,i.useCallback)(()=>{r.current="",window.clearTimeout(n.current)},[]);return(0,i.useEffect)(()=>()=>window.clearTimeout(n.current),[]),[r,o,l]}/**
 * This is the "meat" of the typeahead matching logic. It takes in a list of items,
 * the search and the current item, and returns the next item (or `undefined`).
 *
 * We normalize the search because if a user has repeatedly pressed a character,
 * we want the exact same behavior as if we only had that one character
 * (ie. cycle through items starting with that character)
 *
 * We also reorder the items by wrapping the array around the current item.
 * This is so we always look forward from the current item, and picking the first
 * item will always be the correct one.
 *
 * Finally, if the normalized search is exactly one character, we exclude the
 * current item from the values because otherwise it would be the first to match always
 * and focus would never move. This is as opposed to the regular case, where we
 * don't want focus to move if the current item still matches.
 */function eC(e,t,r){var n;let o=t.length>1&&Array.from(t).every(e=>e===t[0]),l=o?t[0]:t,i=r?e.indexOf(r):-1,a=(n=Math.max(i,0),e.map((t,r)=>e[(n+r)%e.length])),s=1===l.length;s&&(a=a.filter(e=>e!==r));let c=a.find(e=>e.textValue.toLowerCase().startsWith(l.toLowerCase()));return c!==r?c:void 0}eE.displayName="BubbleSelect";let eR=V,eP=z,e_=G,ek=K,eT=U,eI=Y,eO=en,eA=ei,eL=ea,eN=ed,eD=ep,eF=em,eM=ev,eB=ex,eH=eb,eW=eS},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","react-dom":"b8T3j","@radix-ui/number":"64DPx","@radix-ui/primitive":"8XJVQ","@radix-ui/react-collection":"3o8Il","@radix-ui/react-compose-refs":"3TI02","@radix-ui/react-context":"hjQSh","@radix-ui/react-direction":"7D0d7","@radix-ui/react-dismissable-layer":"dMnPR","@radix-ui/react-focus-guards":"f1EAI","@radix-ui/react-focus-scope":"iwX3F","@radix-ui/react-id":"1iLBO","@radix-ui/react-popper":"k666z","@radix-ui/react-portal":"hn7YL","@radix-ui/react-primitive":"12EJa","@radix-ui/react-slot":"cA0RI","@radix-ui/react-use-callback-ref":"bjdTR","@radix-ui/react-use-controllable-state":"E30Th","@radix-ui/react-use-layout-effect":"fkPUP","@radix-ui/react-use-previous":"hcPVs","@radix-ui/react-visually-hidden":"2C47u","aria-hidden":"4ksDn","react-remove-scroll":"6X6Q6","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"64DPx":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");function o(e,[t,r]){return Math.min(r,Math.max(t,e))}n.defineInteropFlag(r),n.export(r,"clamp",()=>o)},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],dMnPR:[function(e,t,r){let n;var o=e("@parcel/transformer-js/src/esmodule-helpers.js");o.defineInteropFlag(r),o.export(r,"DismissableLayer",()=>h),o.export(r,"DismissableLayerBranch",()=>v),o.export(r,"Root",()=>y),o.export(r,"Branch",()=>b);var l=e("@babel/runtime/helpers/esm/extends"),i=o.interopDefault(l),a=e("react"),s=e("@radix-ui/primitive"),c=e("@radix-ui/react-primitive"),u=e("@radix-ui/react-compose-refs"),d=e("@radix-ui/react-use-callback-ref"),f=e("@radix-ui/react-use-escape-keydown");let p="dismissableLayer.update",m=/*#__PURE__*/(0,a.createContext)({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),h=/*#__PURE__*/(0,a.forwardRef)((e,t)=>{var r;let{disableOutsidePointerEvents:o=!1,onEscapeKeyDown:l,onPointerDownOutside:h,onFocusOutside:v,onInteractOutside:y,onDismiss:b,...w}=e,S=(0,a.useContext)(m),[E,j]=(0,a.useState)(null),C=null!==(r=null==E?void 0:E.ownerDocument)&&void 0!==r?r:null==globalThis?void 0:globalThis.document,[,R]=(0,a.useState)({}),P=(0,u.useComposedRefs)(t,e=>j(e)),_=Array.from(S.layers),[k]=[...S.layersWithOutsidePointerEventsDisabled].slice(-1),T=_.indexOf(k),I=E?_.indexOf(E):-1,O=S.layersWithOutsidePointerEventsDisabled.size>0,A=I>=T,L=/* -----------------------------------------------------------------------------------------------*//**
 * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`
 * to mimic layer dismissing behaviour present in OS.
 * Returns props to pass to the node we want to check for outside events.
 */function(e,t=null==globalThis?void 0:globalThis.document){let r=(0,d.useCallbackRef)(e),n=(0,a.useRef)(!1),o=(0,a.useRef)(()=>{});return(0,a.useEffect)(()=>{let e=e=>{if(e.target&&!n.current){let n={originalEvent:e};function l(){x("dismissableLayer.pointerDownOutside",r,n,{discrete:!0})}/**
         * On touch devices, we need to wait for a click event because browsers implement
         * a ~350ms delay between the time the user stops touching the display and when the
         * browser executres events. We need to ensure we don't reactivate pointer-events within
         * this timeframe otherwise the browser may execute events that should have been prevented.
         *
         * Additionally, this also lets us deal automatically with cancellations when a click event
         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.
         *
         * This is why we also continuously remove the previous listener, because we cannot be
         * certain that it was raised, and therefore cleaned-up.
         */"touch"===e.pointerType?(t.removeEventListener("click",o.current),o.current=l,t.addEventListener("click",o.current,{once:!0})):l()}n.current=!1},l=window.setTimeout(()=>{t.addEventListener("pointerdown",e)},0);return()=>{window.clearTimeout(l),t.removeEventListener("pointerdown",e),t.removeEventListener("click",o.current)}},[t,r]),{// ensures we check React component tree (not just DOM tree)
onPointerDownCapture:()=>n.current=!0}}(e=>{let t=e.target,r=[...S.branches].some(e=>e.contains(t));!A||r||(null==h||h(e),null==y||y(e),e.defaultPrevented||null==b||b())},C),N=/**
 * Listens for when focus happens outside a react subtree.
 * Returns props to pass to the root (node) of the subtree we want to check.
 */function(e,t=null==globalThis?void 0:globalThis.document){let r=(0,d.useCallbackRef)(e),n=(0,a.useRef)(!1);return(0,a.useEffect)(()=>{let e=e=>{e.target&&!n.current&&x("dismissableLayer.focusOutside",r,{originalEvent:e},{discrete:!1})};return t.addEventListener("focusin",e),()=>t.removeEventListener("focusin",e)},[t,r]),{onFocusCapture:()=>n.current=!0,onBlurCapture:()=>n.current=!1}}(e=>{let t=e.target,r=[...S.branches].some(e=>e.contains(t));r||(null==v||v(e),null==y||y(e),e.defaultPrevented||null==b||b())},C);return(0,f.useEscapeKeydown)(e=>{let t=I===S.layers.size-1;t&&(null==l||l(e),!e.defaultPrevented&&b&&(e.preventDefault(),b()))},C),(0,a.useEffect)(()=>{if(E)return o&&(0===S.layersWithOutsidePointerEventsDisabled.size&&(n=C.body.style.pointerEvents,C.body.style.pointerEvents="none"),S.layersWithOutsidePointerEventsDisabled.add(E)),S.layers.add(E),g(),()=>{o&&1===S.layersWithOutsidePointerEventsDisabled.size&&(C.body.style.pointerEvents=n)}},[E,C,o,S]),/**
   * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect
   * because a change to `disableOutsidePointerEvents` would remove this layer from the stack
   * and add it to the end again so the layering order wouldn't be _creation order_.
   * We only want them to be removed from context stacks when unmounted.
   */(0,a.useEffect)(()=>()=>{E&&(S.layers.delete(E),S.layersWithOutsidePointerEventsDisabled.delete(E),g())},[E,S]),(0,a.useEffect)(()=>{let e=()=>R({});return document.addEventListener(p,e),()=>document.removeEventListener(p,e)},[]),/*#__PURE__*/(0,a.createElement)(c.Primitive.div,(0,i.default)({},w,{ref:P,style:{pointerEvents:O?A?"auto":"none":void 0,...e.style},onFocusCapture:(0,s.composeEventHandlers)(e.onFocusCapture,N.onFocusCapture),onBlurCapture:(0,s.composeEventHandlers)(e.onBlurCapture,N.onBlurCapture),onPointerDownCapture:(0,s.composeEventHandlers)(e.onPointerDownCapture,L.onPointerDownCapture)}))}),v=/*#__PURE__*/(0,a.forwardRef)((e,t)=>{let r=(0,a.useContext)(m),n=(0,a.useRef)(null),o=(0,u.useComposedRefs)(t,n);return(0,a.useEffect)(()=>{let e=n.current;if(e)return r.branches.add(e),()=>{r.branches.delete(e)}},[r.branches]),/*#__PURE__*/(0,a.createElement)(c.Primitive.div,(0,i.default)({},e,{ref:o}))});function g(){let e=new CustomEvent(p);document.dispatchEvent(e)}function x(e,t,r,{discrete:n}){let o=r.originalEvent.target,l=new CustomEvent(e,{bubbles:!1,cancelable:!0,detail:r});t&&o.addEventListener(e,t,{once:!0}),n?(0,c.dispatchDiscreteCustomEvent)(o,l):o.dispatchEvent(l)}let y=h,b=v},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","@radix-ui/primitive":"8XJVQ","@radix-ui/react-primitive":"12EJa","@radix-ui/react-compose-refs":"3TI02","@radix-ui/react-use-callback-ref":"bjdTR","@radix-ui/react-use-escape-keydown":"8uS0C","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"8uS0C":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"useEscapeKeydown",()=>i);var o=e("react"),l=e("@radix-ui/react-use-callback-ref");/**
 * Listens for when the escape key is down
 */function i(e,t=null==globalThis?void 0:globalThis.document){let r=(0,l.useCallbackRef)(e);(0,o.useEffect)(()=>{let e=e=>{"Escape"===e.key&&r(e)};return t.addEventListener("keydown",e),()=>t.removeEventListener("keydown",e)},[r,t])}},{react:"6uln9","@radix-ui/react-use-callback-ref":"bjdTR","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],f1EAI:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"FocusGuards",()=>i),n.export(r,"Root",()=>c),n.export(r,"useFocusGuards",()=>a);var o=e("react");/** Number of components which have requested interest to have focus guards */let l=0;function i(e){return a(),e.children}/**
 * Injects a pair of focus guards at the edges of the whole DOM tree
 * to ensure `focusin` & `focusout` events can be caught consistently.
 */function a(){(0,o.useEffect)(()=>{var e,t;let r=document.querySelectorAll("[data-radix-focus-guard]");return document.body.insertAdjacentElement("afterbegin",null!==(e=r[0])&&void 0!==e?e:s()),document.body.insertAdjacentElement("beforeend",null!==(t=r[1])&&void 0!==t?t:s()),l++,()=>{1===l&&document.querySelectorAll("[data-radix-focus-guard]").forEach(e=>e.remove()),l--}},[])}function s(){let e=document.createElement("span");return e.setAttribute("data-radix-focus-guard",""),e.tabIndex=0,e.style.cssText="outline: none; opacity: 0; position: fixed; pointer-events: none",e}let c=i},{react:"6uln9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],iwX3F:[function(e,t,r){let n;var o=e("@parcel/transformer-js/src/esmodule-helpers.js");o.defineInteropFlag(r),o.export(r,"FocusScope",()=>m),o.export(r,"Root",()=>b);var l=e("@babel/runtime/helpers/esm/extends"),i=o.interopDefault(l),a=e("react"),s=e("@radix-ui/react-compose-refs"),c=e("@radix-ui/react-primitive"),u=e("@radix-ui/react-use-callback-ref");let d="focusScope.autoFocusOnMount",f="focusScope.autoFocusOnUnmount",p={bubbles:!1,cancelable:!0},m=/*#__PURE__*/(0,a.forwardRef)((e,t)=>{let{loop:r=!1,trapped:n=!1,onMountAutoFocus:o,onUnmountAutoFocus:l,...m}=e,[y,b]=(0,a.useState)(null),w=(0,u.useCallbackRef)(o),S=(0,u.useCallbackRef)(l),E=(0,a.useRef)(null),j=(0,s.useComposedRefs)(t,e=>b(e)),C=(0,a.useRef)({paused:!1,pause(){this.paused=!0},resume(){this.paused=!1}}).current;(0,a.useEffect)(()=>{if(n){function e(e){if(C.paused||!y)return;let t=e.target;y.contains(t)?E.current=t:g(E.current,{select:!0})}function t(e){if(C.paused||!y)return;let t=e.relatedTarget;// A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:
//
// 1. When the user switches app/tabs/windows/the browser itself loses focus.
// 2. In Google Chrome, when the focused element is removed from the DOM.
//
// We let the browser do its thing here because:
//
// 1. The browser already keeps a memory of what's focused for when the page gets refocused.
// 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it
//    throws the CPU to 100%, so we avoid doing anything for this reason here too.
null===t||y.contains(t)||g(E.current,{select:!0});// If the focus has moved to an actual legitimate element (`relatedTarget !== null`)
}// When the focused element gets removed from the DOM, browsers move focus
document.addEventListener("focusin",e),document.addEventListener("focusout",t);let r=new MutationObserver(// back to the document.body. In this case, we move focus to the container
// to keep focus trapped correctly.
function(e){let t=document.activeElement;for(let r of e)r.removedNodes.length>0&&!(null!=y&&y.contains(t))&&g(y)});return y&&r.observe(y,{childList:!0,subtree:!0}),()=>{document.removeEventListener("focusin",e),document.removeEventListener("focusout",t),r.disconnect()}}},[n,y,C.paused]),(0,a.useEffect)(()=>{if(y){x.add(C);let e=document.activeElement,t=y.contains(e);if(!t){let t=new CustomEvent(d,p);y.addEventListener(d,w),y.dispatchEvent(t),t.defaultPrevented||(/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*//**
 * Attempts focusing the first element in a list of candidates.
 * Stops when focus has actually moved.
 */function(e,{select:t=!1}={}){let r=document.activeElement;for(let n of e)if(g(n,{select:t}),document.activeElement!==r)return}(h(y).filter(e=>"A"!==e.tagName),{select:!0}),document.activeElement===e&&g(y))}return()=>{y.removeEventListener(d,w),// We need to delay the focus a little to get around it for now.
// See: https://github.com/facebook/react/issues/17894
setTimeout(()=>{let t=new CustomEvent(f,p);y.addEventListener(f,S),y.dispatchEvent(t),t.defaultPrevented||g(null!=e?e:document.body,{select:!0}),// we need to remove the listener after we `dispatchEvent`
y.removeEventListener(f,S),x.remove(C)},0)}}},[y,w,S,C]);let R=(0,a.useCallback)(e=>{if(!r&&!n||C.paused)return;let t="Tab"===e.key&&!e.altKey&&!e.ctrlKey&&!e.metaKey,o=document.activeElement;if(t&&o){let t=e.currentTarget,[n,l]=/**
 * Returns the first and last tabbable elements inside a container.
 */function(e){let t=h(e),r=v(t,e),n=v(t.reverse(),e);return[r,n]}(t),i=n&&l;i?e.shiftKey||o!==l?e.shiftKey&&o===n&&(e.preventDefault(),r&&g(l,{select:!0})):(e.preventDefault(),r&&g(n,{select:!0})):o===t&&e.preventDefault()}},[r,n,C.paused]);return/*#__PURE__*/(0,a.createElement)(c.Primitive.div,(0,i.default)({tabIndex:-1},m,{ref:j,onKeyDown:R}))});/**
 * Returns a list of potential tabbable candidates.
 *
 * NOTE: This is only a close approximation. For example it doesn't take into account cases like when
 * elements are not visible. This cannot be worked out easily by just reading a property, but rather
 * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker
 * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1
 */function h(e){let t=[],r=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,{acceptNode:e=>{let t="INPUT"===e.tagName&&"hidden"===e.type;return e.disabled||e.hidden||t?NodeFilter.FILTER_SKIP:e.tabIndex>=0?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP// `.tabIndex` is not the same as the `tabindex` attribute. It works on the
}});for(;r.nextNode();)t.push(r.currentNode);// we do not take into account the order of nodes with positive `tabIndex` as it
// hinders accessibility to have tab order different from visual order.
return t}/**
 * Returns the first visible element in a list.
 * NOTE: Only checks visibility up to the `container`.
 */function v(e,t){for(let r of e)// we stop checking if it's hidden at the `container` level (excluding)
if(!function(e,{upTo:t}){if("hidden"===getComputedStyle(e).visibility)return!0;for(;// we stop at `upTo` (excluding it)
e&&(void 0===t||e!==t);){if("none"===getComputedStyle(e).display)return!0;e=e.parentElement}return!1}(r,{upTo:t}))return r}function g(e,{select:t=!1}={}){// only focus if that element is focusable
if(e&&e.focus){var r;let n=document.activeElement;// NOTE: we prevent scrolling on focus, to minimize jarring transitions for users
e.focus({preventScroll:!0}),e!==n&&(r=e)instanceof HTMLInputElement&&"select"in r&&t&&e.select()}}/* -------------------------------------------------------------------------------------------------
 * FocusScope stack
 * -----------------------------------------------------------------------------------------------*/let x=(n=[],{add(e){// pause the currently active focus scope (at the top of the stack)
let t=n[0];e!==t&&(null==t||t.pause()),// remove in case it already exists (because we'll re-add it at the top of the stack)
(n=y(n,e)).unshift(e)},remove(e){var t;null===(t=(n=y(n,e))[0])||void 0===t||t.resume()}});function y(e,t){let r=[...e],n=r.indexOf(t);return -1!==n&&r.splice(n,1),r}let b=m},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","@radix-ui/react-compose-refs":"3TI02","@radix-ui/react-primitive":"12EJa","@radix-ui/react-use-callback-ref":"bjdTR","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],k666z:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"createPopperScope",()=>y),n.export(r,"Popper",()=>S),n.export(r,"PopperAnchor",()=>E),n.export(r,"PopperContent",()=>P),n.export(r,"PopperArrow",()=>k),n.export(r,"Root",()=>A),n.export(r,"Anchor",()=>L),n.export(r,"Content",()=>N),n.export(r,"Arrow",()=>D),n.export(r,"SIDE_OPTIONS",()=>h),n.export(r,"ALIGN_OPTIONS",()=>v);var o=e("@babel/runtime/helpers/esm/extends"),l=n.interopDefault(o),i=e("react"),a=e("@floating-ui/react-dom"),s=e("@radix-ui/react-arrow"),c=e("@radix-ui/react-compose-refs"),u=e("@radix-ui/react-context"),d=e("@radix-ui/react-primitive"),f=e("@radix-ui/react-use-callback-ref"),p=e("@radix-ui/react-use-layout-effect"),m=e("@radix-ui/react-use-size");let h=["top","right","bottom","left"],v=["start","center","end"],g="Popper",[x,y]=(0,u.createContextScope)(g),[b,w]=x(g),S=e=>{let{__scopePopper:t,children:r}=e,[n,o]=(0,i.useState)(null);return/*#__PURE__*/(0,i.createElement)(b,{scope:t,anchor:n,onAnchorChange:o},r)},E=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{__scopePopper:r,virtualRef:n,...o}=e,a=w("PopperAnchor",r),s=(0,i.useRef)(null),u=(0,c.useComposedRefs)(t,s);return(0,i.useEffect)(()=>{// Consumer can anchor the popper to something that isn't
// a DOM node e.g. pointer position, so we override the
// `anchorRef` with their virtual ref in this case.
a.onAnchorChange((null==n?void 0:n.current)||s.current)}),n?null:/*#__PURE__*/(0,i.createElement)(d.Primitive.div,(0,l.default)({},o,{ref:u}))}),j="PopperContent",[C,R]=x(j),P=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{var r,n,o,s,u,h,v,g;let{__scopePopper:x,side:y="bottom",sideOffset:b=0,align:S="center",alignOffset:E=0,arrowPadding:R=0,collisionBoundary:P=[],collisionPadding:_=0,sticky:k="partial",hideWhenDetached:A=!1,avoidCollisions:L=!0,onPlaced:N,...D}=e,F=w(j,x),[M,B]=(0,i.useState)(null),H=(0,c.useComposedRefs)(t,e=>B(e)),[W,V]=(0,i.useState)(null),z=(0,m.useSize)(W),G=null!==(r=null==z?void 0:z.width)&&void 0!==r?r:0,K=null!==(n=null==z?void 0:z.height)&&void 0!==n?n:0,U="number"==typeof _?_:{top:0,right:0,bottom:0,left:0,..._},X=Array.isArray(P)?P:[P],Y=X.length>0,$={padding:U,boundary:X.filter(T),// with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
altBoundary:Y},{refs:J,floatingStyles:q,placement:Z,isPositioned:Q,middlewareData:ee}=(0,a.useFloating)({// default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
strategy:"fixed",placement:y+("center"!==S?"-"+S:""),whileElementsMounted:a.autoUpdate,elements:{reference:F.anchor},middleware:[(0,a.offset)({mainAxis:b+K,alignmentAxis:E}),L&&(0,a.shift)({mainAxis:!0,crossAxis:!1,limiter:"partial"===k?(0,a.limitShift)():void 0,...$}),L&&(0,a.flip)({...$}),(0,a.size)({...$,apply:({elements:e,rects:t,availableWidth:r,availableHeight:n})=>{let{width:o,height:l}=t.reference,i=e.floating.style;i.setProperty("--radix-popper-available-width",`${r}px`),i.setProperty("--radix-popper-available-height",`${n}px`),i.setProperty("--radix-popper-anchor-width",`${o}px`),i.setProperty("--radix-popper-anchor-height",`${l}px`)}}),W&&(0,a.arrow)({element:W,padding:R}),I({arrowWidth:G,arrowHeight:K}),A&&(0,a.hide)({strategy:"referenceHidden"})]}),[et,er]=O(Z),en=(0,f.useCallbackRef)(N);(0,p.useLayoutEffect)(()=>{Q&&(null==en||en())},[Q,en]);let eo=null===(o=ee.arrow)||void 0===o?void 0:o.x,el=null===(s=ee.arrow)||void 0===s?void 0:s.y,ei=(null===(u=ee.arrow)||void 0===u?void 0:u.centerOffset)!==0,[ea,es]=(0,i.useState)();return(0,p.useLayoutEffect)(()=>{M&&es(window.getComputedStyle(M).zIndex)},[M]),/*#__PURE__*/(0,i.createElement)("div",{ref:J.setFloating,"data-radix-popper-content-wrapper":"",style:{...q,transform:Q?q.transform:"translate(0, -200%)",// keep off the page when measuring
minWidth:"max-content",zIndex:ea,"--radix-popper-transform-origin":[null===(h=ee.transformOrigin)||void 0===h?void 0:h.x,null===(v=ee.transformOrigin)||void 0===v?void 0:v.y].join(" ")}// Floating UI interally calculates logical alignment based the `dir` attribute on
,dir:e.dir},/*#__PURE__*/(0,i.createElement)(C,{scope:x,placedSide:et,onArrowChange:V,arrowX:eo,arrowY:el,shouldHideArrow:ei},/*#__PURE__*/(0,i.createElement)(d.Primitive.div,(0,l.default)({"data-side":et,"data-align":er},D,{ref:H,style:{...D.style,// if the PopperContent hasn't been placed yet (not all measurements done)
// we prevent animations so that users's animation don't kick in too early referring wrong sides
animation:Q?void 0:"none",// hide the content if using the hide middleware and should be hidden
opacity:null!==(g=ee.hide)&&void 0!==g&&g.referenceHidden?0:void 0}}))))}),_={top:"bottom",right:"left",bottom:"top",left:"right"},k=/*#__PURE__*/(0,i.forwardRef)(function(e,t){let{__scopePopper:r,...n}=e,o=R("PopperArrow",r),a=_[o.placedSide];return(/*#__PURE__*/// it reports their bounding box which is effectively the largest path inside the SVG.
(0,i.createElement)("span",{ref:o.onArrowChange,style:{position:"absolute",left:o.arrowX,top:o.arrowY,[a]:0,transformOrigin:{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[o.placedSide],transform:{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[o.placedSide],visibility:o.shouldHideArrow?"hidden":void 0}},/*#__PURE__*/(0,i.createElement)(s.Root,(0,l.default)({},n,{ref:t,style:{...n.style,// ensures the element can be measured correctly (mostly for if SVG)
display:"block"}}))))});/* -----------------------------------------------------------------------------------------------*/function T(e){return null!==e}let I=e=>({name:"transformOrigin",options:e,fn(t){var r,n,o,l,i;let{placement:a,rects:s,middlewareData:c}=t,u=(null===(r=c.arrow)||void 0===r?void 0:r.centerOffset)!==0,d=u?0:e.arrowWidth,f=u?0:e.arrowHeight,[p,m]=O(a),h={start:"0%",center:"50%",end:"100%"}[m],v=(null!==(n=null===(o=c.arrow)||void 0===o?void 0:o.x)&&void 0!==n?n:0)+d/2,g=(null!==(l=null===(i=c.arrow)||void 0===i?void 0:i.y)&&void 0!==l?l:0)+f/2,x="",y="";return"bottom"===p?(x=u?h:`${v}px`,y=`${-f}px`):"top"===p?(x=u?h:`${v}px`,y=`${s.floating.height+f}px`):"right"===p?(x=`${-f}px`,y=u?h:`${g}px`):"left"===p&&(x=`${s.floating.width+f}px`,y=u?h:`${g}px`),{data:{x:x,y:y}}}});function O(e){let[t,r="center"]=e.split("-");return[t,r]}let A=S,L=E,N=P,D=k},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","@floating-ui/react-dom":"aFfzN","@radix-ui/react-arrow":"36PIt","@radix-ui/react-compose-refs":"3TI02","@radix-ui/react-context":"hjQSh","@radix-ui/react-primitive":"12EJa","@radix-ui/react-use-callback-ref":"bjdTR","@radix-ui/react-use-layout-effect":"fkPUP","@radix-ui/react-use-size":"1Enki","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],aFfzN:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"autoPlacement",()=>o.autoPlacement),n.export(r,"autoUpdate",()=>o.autoUpdate),n.export(r,"computePosition",()=>o.computePosition),n.export(r,"detectOverflow",()=>o.detectOverflow),n.export(r,"flip",()=>o.flip),n.export(r,"getOverflowAncestors",()=>o.getOverflowAncestors),n.export(r,"hide",()=>o.hide),n.export(r,"inline",()=>o.inline),n.export(r,"limitShift",()=>o.limitShift),n.export(r,"offset",()=>o.offset),n.export(r,"platform",()=>o.platform),n.export(r,"shift",()=>o.shift),n.export(r,"size",()=>o.size),n.export(r,"arrow",()=>a),n.export(r,"useFloating",()=>p);var o=e("@floating-ui/dom"),l=e("react"),i=e("react-dom");/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */let a=e=>({name:"arrow",options:e,fn(t){let{element:r,padding:n}="function"==typeof e?e(t):e;if(r&&({}).hasOwnProperty.call(r,"current")){if(null!=r.current)return(0,o.arrow)({element:r.current,padding:n}).fn(t)}else if(r)return(0,o.arrow)({element:r,padding:n}).fn(t);return{}}});var s="undefined"!=typeof document?l.useLayoutEffect:l.useEffect;// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function c(e,t){let r,n,o;if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if((r=e.length)!=t.length)return!1;for(n=r;0!=n--;)if(!c(e[n],t[n]))return!1;return!0}if((r=(o=Object.keys(e)).length)!==Object.keys(t).length)return!1;for(n=r;0!=n--;)if(!({}).hasOwnProperty.call(t,o[n]))return!1;for(n=r;0!=n--;){let r=o[n];if(("_owner"!==r||!e.$$typeof)&&!c(e[r],t[r]))return!1}return!0}return e!=e&&t!=t}function u(e){if("undefined"==typeof window)return 1;let t=e.ownerDocument.defaultView||window;return t.devicePixelRatio||1}function d(e,t){let r=u(e);return Math.round(t*r)/r}function f(e){let t=l.useRef(e);return s(()=>{t.current=e}),t}/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/react
 */function p(e){void 0===e&&(e={});let{placement:t="bottom",strategy:r="absolute",middleware:n=[],platform:a,elements:{reference:p,floating:m}={},transform:h=!0,whileElementsMounted:v,open:g}=e,[x,y]=l.useState({x:0,y:0,strategy:r,placement:t,middlewareData:{},isPositioned:!1}),[b,w]=l.useState(n);c(b,n)||w(n);let[S,E]=l.useState(null),[j,C]=l.useState(null),R=l.useCallback(e=>{e!=T.current&&(T.current=e,E(e))},[E]),P=l.useCallback(e=>{e!==I.current&&(I.current=e,C(e))},[C]),_=p||S,k=m||j,T=l.useRef(null),I=l.useRef(null),O=l.useRef(x),A=f(v),L=f(a),N=l.useCallback(()=>{if(!T.current||!I.current)return;let e={placement:t,strategy:r,middleware:b};L.current&&(e.platform=L.current),(0,o.computePosition)(T.current,I.current,e).then(e=>{let t={...e,isPositioned:!0};D.current&&!c(O.current,t)&&(O.current=t,i.flushSync(()=>{y(t)}))})},[b,t,r,L]);s(()=>{!1===g&&O.current.isPositioned&&(O.current.isPositioned=!1,y(e=>({...e,isPositioned:!1})))},[g]);let D=l.useRef(!1);s(()=>(D.current=!0,()=>{D.current=!1}),[]),s(()=>{if(_&&(T.current=_),k&&(I.current=k),_&&k){if(A.current)return A.current(_,k,N);N()}},[_,k,N,A]);let F=l.useMemo(()=>({reference:T,floating:I,setReference:R,setFloating:P}),[R,P]),M=l.useMemo(()=>({reference:_,floating:k}),[_,k]),B=l.useMemo(()=>{let e={position:r,left:0,top:0};if(!M.floating)return e;let t=d(M.floating,x.x),n=d(M.floating,x.y);return h?{...e,transform:"translate("+t+"px, "+n+"px)",...u(M.floating)>=1.5&&{willChange:"transform"}}:{position:r,left:t,top:n}},[r,h,M.floating,x.x,x.y]);return l.useMemo(()=>({...x,update:N,refs:F,elements:M,floatingStyles:B}),[x,N,F,M,B])}},{"@floating-ui/dom":"dovGh",react:"6uln9","react-dom":"b8T3j","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],dovGh:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"arrow",()=>o.arrow),n.export(r,"autoPlacement",()=>o.autoPlacement),n.export(r,"detectOverflow",()=>o.detectOverflow),n.export(r,"flip",()=>o.flip),n.export(r,"hide",()=>o.hide),n.export(r,"inline",()=>o.inline),n.export(r,"limitShift",()=>o.limitShift),n.export(r,"offset",()=>o.offset),n.export(r,"shift",()=>o.shift),n.export(r,"size",()=>o.size),n.export(r,"getOverflowAncestors",()=>i.getOverflowAncestors),n.export(r,"autoUpdate",()=>y),n.export(r,"computePosition",()=>b),n.export(r,"platform",()=>x);var o=e("@floating-ui/core"),l=e("@floating-ui/utils"),i=e("@floating-ui/utils/dom");function a(e){let t=(0,i.getComputedStyle)(e),r=parseFloat(t.width)||0,n=parseFloat(t.height)||0,o=(0,i.isHTMLElement)(e),a=o?e.offsetWidth:r,s=o?e.offsetHeight:n,c=(0,l.round)(r)!==a||(0,l.round)(n)!==s;return c&&(r=a,n=s),{width:r,height:n,$:c}}function s(e){return(0,i.isElement)(e)?e:e.contextElement}function c(e){let t=s(e);if(!(0,i.isHTMLElement)(t))return(0,l.createCoords)(1);let r=t.getBoundingClientRect(),{width:n,height:o,$:c}=a(t),u=(c?(0,l.round)(r.width):r.width)/n,d=(c?(0,l.round)(r.height):r.height)/o;return u&&Number.isFinite(u)||(u=1),d&&Number.isFinite(d)||(d=1),{x:u,y:d}}let u=/*#__PURE__*/(0,l.createCoords)(0);function d(e){let t=(0,i.getWindow)(e);return(0,i.isWebKit)()&&t.visualViewport?{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}:u}function f(e,t,r,n){var a;void 0===t&&(t=!1),void 0===r&&(r=!1);let u=e.getBoundingClientRect(),f=s(e),p=(0,l.createCoords)(1);t&&(n?(0,i.isElement)(n)&&(p=c(n)):p=c(e));let m=(void 0===(a=r)&&(a=!1),n&&(!a||n===(0,i.getWindow)(f))&&a)?d(f):(0,l.createCoords)(0),h=(u.left+m.x)/p.x,v=(u.top+m.y)/p.y,g=u.width/p.x,x=u.height/p.y;if(f){let e=(0,i.getWindow)(f),t=n&&(0,i.isElement)(n)?(0,i.getWindow)(n):n,r=e.frameElement;for(;r&&n&&t!==e;){let e=c(r),t=r.getBoundingClientRect(),n=(0,i.getComputedStyle)(r),o=t.left+(r.clientLeft+parseFloat(n.paddingLeft))*e.x,l=t.top+(r.clientTop+parseFloat(n.paddingTop))*e.y;h*=e.x,v*=e.y,g*=e.x,x*=e.y,h+=o,v+=l,r=(0,i.getWindow)(r).frameElement}}return(0,o.rectToClientRect)({width:g,height:x,x:h,y:v})}function p(e){// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
return f((0,i.getDocumentElement)(e)).left+(0,i.getNodeScroll)(e).scrollLeft}function m(e,t,r){let n;if("viewport"===t)n=function(e,t){let r=(0,i.getWindow)(e),n=(0,i.getDocumentElement)(e),o=r.visualViewport,l=n.clientWidth,a=n.clientHeight,s=0,c=0;if(o){l=o.width,a=o.height;let e=(0,i.isWebKit)();(!e||e&&"fixed"===t)&&(s=o.offsetLeft,c=o.offsetTop)}return{width:l,height:a,x:s,y:c}}(e,r);else if("document"===t)n=// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function(e){let t=(0,i.getDocumentElement)(e),r=(0,i.getNodeScroll)(e),n=e.ownerDocument.body,o=(0,l.max)(t.scrollWidth,t.clientWidth,n.scrollWidth,n.clientWidth),a=(0,l.max)(t.scrollHeight,t.clientHeight,n.scrollHeight,n.clientHeight),s=-r.scrollLeft+p(e),c=-r.scrollTop;return"rtl"===(0,i.getComputedStyle)(n).direction&&(s+=(0,l.max)(t.clientWidth,n.clientWidth)-o),{width:o,height:a,x:s,y:c}}((0,i.getDocumentElement)(e));else if((0,i.isElement)(t))n=// Returns the inner client rect, subtracting scrollbars if present.
function(e,t){let r=f(e,!0,"fixed"===t),n=r.top+e.clientTop,o=r.left+e.clientLeft,a=(0,i.isHTMLElement)(e)?c(e):(0,l.createCoords)(1),s=e.clientWidth*a.x,u=e.clientHeight*a.y,d=o*a.x,p=n*a.y;return{width:s,height:u,x:d,y:p}}(t,r);else{let r=d(e);n={...t,x:t.x-r.x,y:t.y-r.y}}return(0,o.rectToClientRect)(n)}function h(e,t){return(0,i.isHTMLElement)(e)&&"fixed"!==(0,i.getComputedStyle)(e).position?t?t(e):e.offsetParent:null}// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function v(e,t){let r=(0,i.getWindow)(e);if(!(0,i.isHTMLElement)(e))return r;let n=h(e,t);for(;n&&(0,i.isTableElement)(n)&&"static"===(0,i.getComputedStyle)(n).position;)n=h(n,t);return n&&("html"===(0,i.getNodeName)(n)||"body"===(0,i.getNodeName)(n)&&"static"===(0,i.getComputedStyle)(n).position&&!(0,i.isContainingBlock)(n))?r:n||(0,i.getContainingBlock)(e)||r}let g=async function(e){let{reference:t,floating:r,strategy:n}=e,o=this.getOffsetParent||v,a=this.getDimensions;return{reference:function(e,t,r){let n=(0,i.isHTMLElement)(t),o=(0,i.getDocumentElement)(t),a="fixed"===r,s=f(e,!0,a,t),c={scrollLeft:0,scrollTop:0},u=(0,l.createCoords)(0);if(n||!n&&!a){if(("body"!==(0,i.getNodeName)(t)||(0,i.isOverflowElement)(o))&&(c=(0,i.getNodeScroll)(t)),n){let e=f(t,!0,a,t);u.x=e.x+t.clientLeft,u.y=e.y+t.clientTop}else o&&(u.x=p(o))}return{x:s.left+c.scrollLeft-u.x,y:s.top+c.scrollTop-u.y,width:s.width,height:s.height}}(t,await o(r),n),floating:{x:0,y:0,...await a(r)}}},x={convertOffsetParentRelativeRectToViewportRelativeRect:function(e){let{rect:t,offsetParent:r,strategy:n}=e,o=(0,i.isHTMLElement)(r),a=(0,i.getDocumentElement)(r);if(r===a)return t;let s={scrollLeft:0,scrollTop:0},u=(0,l.createCoords)(1),d=(0,l.createCoords)(0);if((o||!o&&"fixed"!==n)&&(("body"!==(0,i.getNodeName)(r)||(0,i.isOverflowElement)(a))&&(s=(0,i.getNodeScroll)(r)),(0,i.isHTMLElement)(r))){let e=f(r);u=c(r),d.x=e.x+r.clientLeft,d.y=e.y+r.clientTop}return{width:t.width*u.x,height:t.height*u.y,x:t.x*u.x-s.scrollLeft*u.x+d.x,y:t.y*u.y-s.scrollTop*u.y+d.y}},getDocumentElement:i.getDocumentElement,getClippingRect:// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function(e){let{element:t,boundary:r,rootBoundary:n,strategy:o}=e,a="clippingAncestors"===r?// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function(e,t){let r=t.get(e);if(r)return r;let n=(0,i.getOverflowAncestors)(e).filter(e=>(0,i.isElement)(e)&&"body"!==(0,i.getNodeName)(e)),o=null,l="fixed"===(0,i.getComputedStyle)(e).position,a=l?(0,i.getParentNode)(e):e;// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
for(;(0,i.isElement)(a)&&!(0,i.isLastTraversableNode)(a);){let t=(0,i.getComputedStyle)(a),r=(0,i.isContainingBlock)(a);r||"fixed"!==t.position||(o=null);let s=l?!r&&!o:!r&&"static"===t.position&&!!o&&["absolute","fixed"].includes(o.position)||(0,i.isOverflowElement)(a)&&!r&&function e(t,r){let n=(0,i.getParentNode)(t);return!(n===r||!(0,i.isElement)(n)||(0,i.isLastTraversableNode)(n))&&("fixed"===(0,i.getComputedStyle)(n).position||e(n,r))}(e,a);s?n=n.filter(e=>e!==a):o=t,a=(0,i.getParentNode)(a)}return t.set(e,n),n}(t,this._c):[].concat(r),s=[...a,n],c=s[0],u=s.reduce((e,r)=>{let n=m(t,r,o);return e.top=(0,l.max)(n.top,e.top),e.right=(0,l.min)(n.right,e.right),e.bottom=(0,l.min)(n.bottom,e.bottom),e.left=(0,l.max)(n.left,e.left),e},m(t,c,o));return{width:u.right-u.left,height:u.bottom-u.top,x:u.left,y:u.top}},getOffsetParent:v,getElementRects:g,getClientRects:function(e){return Array.from(e.getClientRects())},getDimensions:function(e){return a(e)},getScale:c,isElement:i.isElement,isRTL:function(e){return"rtl"===(0,i.getComputedStyle)(e).direction}};/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */function y(e,t,r,n){let o;void 0===n&&(n={});let{ancestorScroll:a=!0,ancestorResize:c=!0,elementResize:u="function"==typeof ResizeObserver,layoutShift:d="function"==typeof IntersectionObserver,animationFrame:p=!1}=n,m=s(e),h=a||c?[...m?(0,i.getOverflowAncestors)(m):[],...(0,i.getOverflowAncestors)(t)]:[];h.forEach(e=>{a&&e.addEventListener("scroll",r,{passive:!0}),c&&e.addEventListener("resize",r)});let v=m&&d?// https://samthor.au/2021/observing-dom/
function(e,t){let r,n=null,o=(0,i.getDocumentElement)(e);function a(){clearTimeout(r),n&&n.disconnect(),n=null}return!function i(s,c){void 0===s&&(s=!1),void 0===c&&(c=1),a();let{left:u,top:d,width:f,height:p}=e.getBoundingClientRect();if(s||t(),!f||!p)return;let m=(0,l.floor)(d),h=(0,l.floor)(o.clientWidth-(u+f)),v=(0,l.floor)(o.clientHeight-(d+p)),g=(0,l.floor)(u),x={rootMargin:-m+"px "+-h+"px "+-v+"px "+-g+"px",threshold:(0,l.max)(0,(0,l.min)(1,c))||1},y=!0;function b(e){let t=e[0].intersectionRatio;if(t!==c){if(!y)return i();t?i(!1,t):r=setTimeout(()=>{i(!1,1e-7)},100)}y=!1}// Older browsers don't support a `document` as the root and will throw an
// error.
try{n=new IntersectionObserver(b,{...x,// Handle <iframe>s
root:o.ownerDocument})}catch(e){n=new IntersectionObserver(b,x)}n.observe(e)}(!0),a}(m,r):null,g=-1,x=null;u&&(x=new ResizeObserver(e=>{let[n]=e;n&&n.target===m&&x&&(// Prevent update loops when using the `size` middleware.
// https://github.com/floating-ui/floating-ui/issues/1740
x.unobserve(t),cancelAnimationFrame(g),g=requestAnimationFrame(()=>{x&&x.observe(t)})),r()}),m&&!p&&x.observe(m),x.observe(t));let y=p?f(e):null;return p&&function t(){let n=f(e);y&&(n.x!==y.x||n.y!==y.y||n.width!==y.width||n.height!==y.height)&&r(),y=n,o=requestAnimationFrame(t)}(),r(),()=>{h.forEach(e=>{a&&e.removeEventListener("scroll",r),c&&e.removeEventListener("resize",r)}),v&&v(),x&&x.disconnect(),x=null,p&&cancelAnimationFrame(o)}}/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */let b=(e,t,r)=>{// This caches the expensive `getClippingElementAncestors` function so that
// multiple lifecycle resets re-use the same result. It only lives for a
// single call. If other functions become expensive, we can add them as well.
let n=new Map,l={platform:x,...r},i={...l.platform,_c:n};return(0,o.computePosition)(e,t,{...l,platform:i})}},{"@floating-ui/core":"cwfEo","@floating-ui/utils":"hEn7B","@floating-ui/utils/dom":"h2ZOG","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],cwfEo:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"rectToClientRect",()=>o.rectToClientRect),n.export(r,"arrow",()=>s),n.export(r,"autoPlacement",()=>c),n.export(r,"computePosition",()=>i),n.export(r,"detectOverflow",()=>a),n.export(r,"flip",()=>u),n.export(r,"hide",()=>p),n.export(r,"inline",()=>h),n.export(r,"limitShift",()=>y),n.export(r,"offset",()=>g),n.export(r,"shift",()=>x),n.export(r,"size",()=>b);var o=e("@floating-ui/utils");function l(e,t,r){let n,{reference:l,floating:i}=e,a=(0,o.getSideAxis)(t),s=(0,o.getAlignmentAxis)(t),c=(0,o.getAxisLength)(s),u=(0,o.getSide)(t),d="y"===a,f=l.x+l.width/2-i.width/2,p=l.y+l.height/2-i.height/2,m=l[c]/2-i[c]/2;switch(u){case"top":n={x:f,y:l.y-i.height};break;case"bottom":n={x:f,y:l.y+l.height};break;case"right":n={x:l.x+l.width,y:p};break;case"left":n={x:l.x-i.width,y:p};break;default:n={x:l.x,y:l.y}}switch((0,o.getAlignment)(t)){case"start":n[s]-=m*(r&&d?-1:1);break;case"end":n[s]+=m*(r&&d?-1:1)}return n}/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */let i=async(e,t,r)=>{let{placement:n="bottom",strategy:o="absolute",middleware:i=[],platform:a}=r,s=i.filter(Boolean),c=await (null==a.isRTL?void 0:a.isRTL(t)),u=await a.getElementRects({reference:e,floating:t,strategy:o}),{x:d,y:f}=l(u,n,c),p=n,m={},h=0;for(let r=0;r<s.length;r++){let{name:i,fn:v}=s[r],{x:g,y:x,data:y,reset:b}=await v({x:d,y:f,initialPlacement:n,placement:p,strategy:o,middlewareData:m,rects:u,platform:a,elements:{reference:e,floating:t}});if(d=null!=g?g:d,f=null!=x?x:f,m={...m,[i]:{...m[i],...y}},b&&h<=50){h++,"object"==typeof b&&(b.placement&&(p=b.placement),b.rects&&(u=!0===b.rects?await a.getElementRects({reference:e,floating:t,strategy:o}):b.rects),{x:d,y:f}=l(u,p,c)),r=-1;continue}}return{x:d,y:f,placement:p,strategy:o,middlewareData:m}};/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */async function a(e,t){var r;void 0===t&&(t={});let{x:n,y:l,platform:i,rects:a,elements:s,strategy:c}=e,{boundary:u="clippingAncestors",rootBoundary:d="viewport",elementContext:f="floating",altBoundary:p=!1,padding:m=0}=(0,o.evaluate)(t,e),h=(0,o.getPaddingObject)(m),v=s[p?"floating"===f?"reference":"floating":f],g=(0,o.rectToClientRect)(await i.getClippingRect({element:null==(r=await (null==i.isElement?void 0:i.isElement(v)))||r?v:v.contextElement||await (null==i.getDocumentElement?void 0:i.getDocumentElement(s.floating)),boundary:u,rootBoundary:d,strategy:c})),x="floating"===f?{...a.floating,x:n,y:l}:a.reference,y=await (null==i.getOffsetParent?void 0:i.getOffsetParent(s.floating)),b=await (null==i.isElement?void 0:i.isElement(y))&&await (null==i.getScale?void 0:i.getScale(y))||{x:1,y:1},w=(0,o.rectToClientRect)(i.convertOffsetParentRelativeRectToViewportRelativeRect?await i.convertOffsetParentRelativeRectToViewportRelativeRect({rect:x,offsetParent:y,strategy:c}):x);return{top:(g.top-w.top+h.top)/b.y,bottom:(w.bottom-g.bottom+h.bottom)/b.y,left:(g.left-w.left+h.left)/b.x,right:(w.right-g.right+h.right)/b.x}}/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */let s=e=>({name:"arrow",options:e,async fn(t){let{x:r,y:n,placement:l,rects:i,platform:a,elements:s}=t,{element:c,padding:u=0}=(0,o.evaluate)(e,t)||{};if(null==c)return{};let d=(0,o.getPaddingObject)(u),f={x:r,y:n},p=(0,o.getAlignmentAxis)(l),m=(0,o.getAxisLength)(p),h=await a.getDimensions(c),v="y"===p,g=v?"clientHeight":"clientWidth",x=i.reference[m]+i.reference[p]-f[p]-i.floating[m],y=f[p]-i.reference[p],b=await (null==a.getOffsetParent?void 0:a.getOffsetParent(c)),w=b?b[g]:0;// DOM platform can return `window` as the `offsetParent`.
    w&&await (null==a.isElement?void 0:a.isElement(b))||(w=s.floating[g]||i.floating[m]);// If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    let S=w/2-h[m]/2-1,E=(0,o.min)(d[v?"top":"left"],S),j=(0,o.min)(d[v?"bottom":"right"],S),C=w-h[m]-j,R=w/2-h[m]/2+(x/2-y/2),P=(0,o.clamp)(E,R,C),_=null!=(0,o.getAlignment)(l)&&R!=P&&i.reference[m]/2-(R<E?E:j)-h[m]/2<0,k=_?R<E?E-R:C-R:0;return{[p]:f[p]-k,data:{[p]:P,centerOffset:R-P+k}}}}),c=function(e){return void 0===e&&(e={}),{name:"autoPlacement",options:e,async fn(t){var r,n,l;let{rects:i,middlewareData:s,placement:c,platform:u,elements:d}=t,{crossAxis:f=!1,alignment:p,allowedPlacements:m=o.placements,autoAlignment:h=!0,...v}=(0,o.evaluate)(e,t),g=void 0!==p||m===o.placements?function(e,t,r){let n=e?[...r.filter(t=>(0,o.getAlignment)(t)===e),...r.filter(t=>(0,o.getAlignment)(t)!==e)]:r.filter(e=>(0,o.getSide)(e)===e);return n.filter(r=>!e||(0,o.getAlignment)(r)===e||!!t&&(0,o.getOppositeAlignmentPlacement)(r)!==r)}(p||null,h,m):m,x=await a(t,v),y=(null==(r=s.autoPlacement)?void 0:r.index)||0,b=g[y];if(null==b)return{};let w=(0,o.getAlignmentSides)(b,i,await (null==u.isRTL?void 0:u.isRTL(d.floating)));// Make `computeCoords` start from the right place.
if(c!==b)return{reset:{placement:g[0]}};let S=[x[(0,o.getSide)(b)],x[w[0]],x[w[1]]],E=[...(null==(n=s.autoPlacement)?void 0:n.overflows)||[],{placement:b,overflows:S}],j=g[y+1];// There are more placements to check.
if(j)return{data:{index:y+1,overflows:E},reset:{placement:j}};let C=E.map(e=>{let t=(0,o.getAlignment)(e.placement);return[e.placement,t&&f?e.overflows.slice(0,2).reduce((e,t)=>e+t,0):e.overflows[0],e.overflows]}).sort((e,t)=>e[1]-t[1]),R=C.filter(e=>e[2].slice(0,// side.
    (0,o.getAlignment)(e[0])?2:3).every(e=>e<=0)),P=(null==(l=R[0])?void 0:l[0])||C[0][0];return P!==c?{data:{index:y+1,overflows:E},reset:{placement:P}}:{}}}},u=function(e){return void 0===e&&(e={}),{name:"flip",options:e,async fn(t){var r,n,l,i;let{placement:s,middlewareData:c,rects:u,initialPlacement:d,platform:f,elements:p}=t,{mainAxis:m=!0,crossAxis:h=!0,fallbackPlacements:v,fallbackStrategy:g="bestFit",fallbackAxisSideDirection:x="none",flipAlignment:y=!0,...b}=(0,o.evaluate)(e,t),w=(0,o.getSide)(s),S=(0,o.getSide)(d)===d,E=await (null==f.isRTL?void 0:f.isRTL(p.floating)),j=v||(S||!y?[(0,o.getOppositePlacement)(d)]:(0,o.getExpandedPlacements)(d));v||"none"===x||j.push(...(0,o.getOppositeAxisPlacements)(d,y,x,E));let C=[d,...j],R=await a(t,b),P=[],_=(null==(r=c.flip)?void 0:r.overflows)||[];if(m&&P.push(R[w]),h){let e=(0,o.getAlignmentSides)(s,u,E);P.push(R[e[0]],R[e[1]])}// One or more sides is overflowing.
if(_=[..._,{placement:s,overflows:P}],!P.every(e=>e<=0)){let e=((null==(n=c.flip)?void 0:n.index)||0)+1,t=C[e];if(t)return{data:{index:e,overflows:_},reset:{placement:t}};// First, find the candidates that fit on the mainAxis side of overflow,
// then find the placement that fits the best on the main crossAxis side.
let r=null==(l=_.filter(e=>e.overflows[0]<=0).sort((e,t)=>e.overflows[1]-t.overflows[1])[0])?void 0:l.placement;// Otherwise fallback.
if(!r)switch(g){case"bestFit":{let e=null==(i=_.map(e=>[e.placement,e.overflows.filter(e=>e>0).reduce((e,t)=>e+t,0)]).sort((e,t)=>e[1]-t[1])[0])?void 0:i[0];e&&(r=e);break}case"initialPlacement":r=d}if(s!==r)return{reset:{placement:r}}}return{}}}};function d(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function f(e){return(0,o.sides).some(t=>e[t]>=0)}/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */let p=function(e){return void 0===e&&(e={}),{name:"hide",options:e,async fn(t){let{rects:r}=t,{strategy:n="referenceHidden",...l}=(0,o.evaluate)(e,t);switch(n){case"referenceHidden":{let e=await a(t,{...l,elementContext:"reference"}),n=d(e,r.reference);return{data:{referenceHiddenOffsets:n,referenceHidden:f(n)}}}case"escaped":{let e=await a(t,{...l,altBoundary:!0}),n=d(e,r.floating);return{data:{escapedOffsets:n,escaped:f(n)}}}default:return{}}}}};function m(e){let t=(0,o.min)(...e.map(e=>e.left)),r=(0,o.min)(...e.map(e=>e.top)),n=(0,o.max)(...e.map(e=>e.right)),l=(0,o.max)(...e.map(e=>e.bottom));return{x:t,y:r,width:n-t,height:l-r}}/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */let h=function(e){return void 0===e&&(e={}),{name:"inline",options:e,async fn(t){let{placement:r,elements:n,rects:l,platform:i,strategy:a}=t,{padding:s=2,x:c,y:u}=(0,o.evaluate)(e,t),d=Array.from(await (null==i.getClientRects?void 0:i.getClientRects(n.reference))||[]),f=function(e){let t=e.slice().sort((e,t)=>e.y-t.y),r=[],n=null;for(let e=0;e<t.length;e++){let o=t[e];!n||o.y-n.y>n.height/2?r.push([o]):r[r.length-1].push(o),n=o}return r.map(e=>(0,o.rectToClientRect)(m(e)))}(d),p=(0,o.rectToClientRect)(m(d)),h=(0,o.getPaddingObject)(s),v=await i.getElementRects({reference:{getBoundingClientRect:function(){// There are two rects and they are disjoined.
if(2===f.length&&f[0].left>f[1].right&&null!=c&&null!=u)return f.find(e=>c>e.left-h.left&&c<e.right+h.right&&u>e.top-h.top&&u<e.bottom+h.bottom)||p;// There are 2 or more connected rects.
if(f.length>=2){if("y"===(0,o.getSideAxis)(r)){let e=f[0],t=f[f.length-1],n="top"===(0,o.getSide)(r),l=e.top,i=t.bottom,a=n?e.left:t.left,s=n?e.right:t.right;return{top:l,bottom:i,left:a,right:s,width:s-a,height:i-l,x:a,y:l}}let e="left"===(0,o.getSide)(r),t=(0,o.max)(...f.map(e=>e.right)),n=(0,o.min)(...f.map(e=>e.left)),l=f.filter(r=>e?r.left===n:r.right===t),i=l[0].top,a=l[l.length-1].bottom,s=t-n;return{top:i,bottom:a,left:n,right:t,width:s,height:a-i,x:n,y:i}}return p}},floating:n.floating,strategy:a});return l.reference.x!==v.reference.x||l.reference.y!==v.reference.y||l.reference.width!==v.reference.width||l.reference.height!==v.reference.height?{reset:{rects:v}}:{}}}};// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function v(e,t){let{placement:r,platform:n,elements:l}=e,i=await (null==n.isRTL?void 0:n.isRTL(l.floating)),a=(0,o.getSide)(r),s=(0,o.getAlignment)(r),c="y"===(0,o.getSideAxis)(r),u=["left","top"].includes(a)?-1:1,d=i&&c?-1:1,f=(0,o.evaluate)(t,e),{mainAxis:p,crossAxis:m,alignmentAxis:h}="number"==typeof f?{mainAxis:f,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...f};return s&&"number"==typeof h&&(m="end"===s?-1*h:h),c?{x:m*d,y:p*u}:{x:p*u,y:m*d}}/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */let g=function(e){return void 0===e&&(e=0),{name:"offset",options:e,async fn(t){let{x:r,y:n}=t,o=await v(t,e);return{x:r+o.x,y:n+o.y,data:o}}}},x=function(e){return void 0===e&&(e={}),{name:"shift",options:e,async fn(t){let{x:r,y:n,placement:l}=t,{mainAxis:i=!0,crossAxis:s=!1,limiter:c={fn:e=>{let{x:t,y:r}=e;return{x:t,y:r}}},...u}=(0,o.evaluate)(e,t),d={x:r,y:n},f=await a(t,u),p=(0,o.getSideAxis)((0,o.getSide)(l)),m=(0,o.getOppositeAxis)(p),h=d[m],v=d[p];if(i){let e=h+f["y"===m?"top":"left"],t=h-f["y"===m?"bottom":"right"];h=(0,o.clamp)(e,h,t)}if(s){let e="y"===p?"top":"left",t="y"===p?"bottom":"right",r=v+f[e],n=v-f[t];v=(0,o.clamp)(r,v,n)}let g=c.fn({...t,[m]:h,[p]:v});return{...g,data:{x:g.x-r,y:g.y-n}}}}},y=function(e){return void 0===e&&(e={}),{options:e,fn(t){let{x:r,y:n,placement:l,rects:i,middlewareData:a}=t,{offset:s=0,mainAxis:c=!0,crossAxis:u=!0}=(0,o.evaluate)(e,t),d={x:r,y:n},f=(0,o.getSideAxis)(l),p=(0,o.getOppositeAxis)(f),m=d[p],h=d[f],v=(0,o.evaluate)(s,t),g="number"==typeof v?{mainAxis:v,crossAxis:0}:{mainAxis:0,crossAxis:0,...v};if(c){let e="y"===p?"height":"width",t=i.reference[p]-i.floating[e]+g.mainAxis,r=i.reference[p]+i.reference[e]-g.mainAxis;m<t?m=t:m>r&&(m=r)}if(u){var x,y;let e="y"===p?"width":"height",t=["top","left"].includes((0,o.getSide)(l)),r=i.reference[f]-i.floating[e]+(t&&(null==(x=a.offset)?void 0:x[f])||0)+(t?0:g.crossAxis),n=i.reference[f]+i.reference[e]+(t?0:(null==(y=a.offset)?void 0:y[f])||0)-(t?g.crossAxis:0);h<r?h=r:h>n&&(h=n)}return{[p]:m,[f]:h}}}},b=function(e){return void 0===e&&(e={}),{name:"size",options:e,async fn(t){let r,n;let{placement:l,rects:i,platform:s,elements:c}=t,{apply:u=()=>{},...d}=(0,o.evaluate)(e,t),f=await a(t,d),p=(0,o.getSide)(l),m=(0,o.getAlignment)(l),h="y"===(0,o.getSideAxis)(l),{width:v,height:g}=i.floating;"top"===p||"bottom"===p?(r=p,n=m===(await (null==s.isRTL?void 0:s.isRTL(c.floating))?"start":"end")?"left":"right"):(n=p,r="end"===m?"top":"bottom");let x=g-f[r],y=v-f[n],b=!t.middlewareData.shift,w=x,S=y;if(h){let e=v-f.left-f.right;S=m||b?(0,o.min)(y,e):e}else{let e=g-f.top-f.bottom;w=m||b?(0,o.min)(x,e):e}if(b&&!m){let e=(0,o.max)(f.left,0),t=(0,o.max)(f.right,0),r=(0,o.max)(f.top,0),n=(0,o.max)(f.bottom,0);h?S=v-2*(0!==e||0!==t?e+t:(0,o.max)(f.left,f.right)):w=g-2*(0!==r||0!==n?r+n:(0,o.max)(f.top,f.bottom))}await u({...t,availableWidth:S,availableHeight:w});let E=await s.getDimensions(c.floating);return v!==E.width||g!==E.height?{reset:{rects:!0}}:{}}}}},{"@floating-ui/utils":"hEn7B","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],hEn7B:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"alignments",()=>l),n.export(r,"clamp",()=>m),n.export(r,"createCoords",()=>d),n.export(r,"evaluate",()=>h),n.export(r,"expandPaddingObject",()=>P),n.export(r,"floor",()=>u),n.export(r,"getAlignment",()=>g),n.export(r,"getAlignmentAxis",()=>w),n.export(r,"getAlignmentSides",()=>S),n.export(r,"getAxisLength",()=>y),n.export(r,"getExpandedPlacements",()=>E),n.export(r,"getOppositeAlignmentPlacement",()=>j),n.export(r,"getOppositeAxis",()=>x),n.export(r,"getOppositeAxisPlacements",()=>C),n.export(r,"getOppositePlacement",()=>R),n.export(r,"getPaddingObject",()=>_),n.export(r,"getSide",()=>v),n.export(r,"getSideAxis",()=>b),n.export(r,"max",()=>s),n.export(r,"min",()=>a),n.export(r,"placements",()=>i),n.export(r,"rectToClientRect",()=>k),n.export(r,"round",()=>c),n.export(r,"sides",()=>o);let o=["top","right","bottom","left"],l=["start","end"],i=/*#__PURE__*/o.reduce((e,t)=>e.concat(t,t+"-"+l[0],t+"-"+l[1]),[]),a=Math.min,s=Math.max,c=Math.round,u=Math.floor,d=e=>({x:e,y:e}),f={left:"right",right:"left",bottom:"top",top:"bottom"},p={start:"end",end:"start"};function m(e,t,r){return s(e,a(t,r))}function h(e,t){return"function"==typeof e?e(t):e}function v(e){return e.split("-")[0]}function g(e){return e.split("-")[1]}function x(e){return"x"===e?"y":"x"}function y(e){return"y"===e?"height":"width"}function b(e){return["top","bottom"].includes(v(e))?"y":"x"}function w(e){return x(b(e))}function S(e,t,r){void 0===r&&(r=!1);let n=g(e),o=w(e),l=y(o),i="x"===o?n===(r?"end":"start")?"right":"left":"start"===n?"bottom":"top";return t.reference[l]>t.floating[l]&&(i=R(i)),[i,R(i)]}function E(e){let t=R(e);return[j(e),t,j(t)]}function j(e){return e.replace(/start|end/g,e=>p[e])}function C(e,t,r,n){let o=g(e),l=function(e,t,r){let n=["left","right"],o=["right","left"];switch(e){case"top":case"bottom":if(r)return t?o:n;return t?n:o;case"left":case"right":return t?["top","bottom"]:["bottom","top"];default:return[]}}(v(e),"start"===r,n);return o&&(l=l.map(e=>e+"-"+o),t&&(l=l.concat(l.map(j)))),l}function R(e){return e.replace(/left|right|bottom|top/g,e=>f[e])}function P(e){return{top:0,right:0,bottom:0,left:0,...e}}function _(e){return"number"!=typeof e?P(e):{top:e,right:e,bottom:e,left:e}}function k(e){return{...e,top:e.y,left:e.x,right:e.x+e.width,bottom:e.y+e.height}}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],h2ZOG:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");function o(e){return a(e)?(e.nodeName||"").toLowerCase():"#document"}function l(e){var t;return(null==e?void 0:null==(t=e.ownerDocument)?void 0:t.defaultView)||window}function i(e){var t;return null==(t=(a(e)?e.ownerDocument:e.document)||window.document)?void 0:t.documentElement}function a(e){return e instanceof Node||e instanceof l(e).Node}function s(e){return e instanceof Element||e instanceof l(e).Element}function c(e){return e instanceof HTMLElement||e instanceof l(e).HTMLElement}function u(e){return(// Browsers without `ShadowRoot` support.
"undefined"!=typeof ShadowRoot&&(e instanceof ShadowRoot||e instanceof l(e).ShadowRoot))}function d(e){let{overflow:t,overflowX:r,overflowY:n,display:o}=g(e);return/auto|scroll|overlay|hidden|clip/.test(t+n+r)&&!["inline","contents"].includes(o)}function f(e){return["table","td","th"].includes(o(e))}function p(e){let t=h(),r=g(e);// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
return"none"!==r.transform||"none"!==r.perspective||!!r.containerType&&"normal"!==r.containerType||!t&&!!r.backdropFilter&&"none"!==r.backdropFilter||!t&&!!r.filter&&"none"!==r.filter||["transform","perspective","filter"].some(e=>(r.willChange||"").includes(e))||["paint","layout","strict","content"].some(e=>(r.contain||"").includes(e))}function m(e){let t=y(e);for(;c(t)&&!v(t);){if(p(t))return t;t=y(t)}return null}function h(){return"undefined"!=typeof CSS&&!!CSS.supports&&CSS.supports("-webkit-backdrop-filter","none")}function v(e){return["html","body","#document"].includes(o(e))}function g(e){return l(e).getComputedStyle(e)}function x(e){return s(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function y(e){if("html"===o(e))return e;let t=e.assignedSlot||// DOM Element detected.
e.parentNode||// ShadowRoot detected.
u(e)&&e.host||// Fallback.
i(e);return u(t)?t.host:t}function b(e){let t=y(e);return v(t)?e.ownerDocument?e.ownerDocument.body:e.body:c(t)&&d(t)?t:b(t)}n.defineInteropFlag(r),n.export(r,"getComputedStyle",()=>g),n.export(r,"getContainingBlock",()=>m),n.export(r,"getDocumentElement",()=>i),n.export(r,"getNearestOverflowAncestor",()=>b),n.export(r,"getNodeName",()=>o),n.export(r,"getNodeScroll",()=>x),n.export(r,"getOverflowAncestors",()=>function e(t,r){var n;void 0===r&&(r=[]);let o=b(t),i=o===(null==(n=t.ownerDocument)?void 0:n.body),a=l(o);return i?r.concat(a,a.visualViewport||[],d(o)?o:[],a.frameElement?e(a.frameElement):[]):r.concat(o,e(o))}),n.export(r,"getParentNode",()=>y),n.export(r,"getWindow",()=>l),n.export(r,"isContainingBlock",()=>p),n.export(r,"isElement",()=>s),n.export(r,"isHTMLElement",()=>c),n.export(r,"isLastTraversableNode",()=>v),n.export(r,"isNode",()=>a),n.export(r,"isOverflowElement",()=>d),n.export(r,"isShadowRoot",()=>u),n.export(r,"isTableElement",()=>f),n.export(r,"isWebKit",()=>h)},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"36PIt":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"Arrow",()=>s),n.export(r,"Root",()=>c);var o=e("@babel/runtime/helpers/esm/extends"),l=n.interopDefault(o),i=e("react"),a=e("@radix-ui/react-primitive");let s=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{let{children:r,width:n=10,height:o=5,...s}=e;return/*#__PURE__*/(0,i.createElement)(a.Primitive.svg,(0,l.default)({},s,{ref:t,width:n,height:o,viewBox:"0 0 30 10",preserveAspectRatio:"none"}),e.asChild?r:/*#__PURE__*/(0,i.createElement)("polygon",{points:"0,0 30,0 15,10"}))}),c=s},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","@radix-ui/react-primitive":"12EJa","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"1Enki":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"useSize",()=>i);var o=e("react"),l=e("@radix-ui/react-use-layout-effect");function i(e){let[t,r]=(0,o.useState)(void 0);return(0,l.useLayoutEffect)(()=>{if(e){// provide size as early as possible
r({width:e.offsetWidth,height:e.offsetHeight});let t=new ResizeObserver(t=>{let n,o;if(!Array.isArray(t)||!t.length)return;let l=t[0];if("borderBoxSize"in l){let e=l.borderBoxSize,t=Array.isArray(e)?e[0]:e;// iron out differences between browsers
n=t.inlineSize,o=t.blockSize}else // for browsers that don't support `borderBoxSize`
// we calculate it ourselves to get the correct border box.
n=e.offsetWidth,o=e.offsetHeight;r({width:n,height:o})});return t.observe(e,{box:"border-box"}),()=>t.unobserve(e)}r(void 0)},[e]),t}},{react:"6uln9","@radix-ui/react-use-layout-effect":"fkPUP","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],hn7YL:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"Portal",()=>u),n.export(r,"Root",()=>d);var o=e("@babel/runtime/helpers/esm/extends"),l=n.interopDefault(o),i=e("react"),a=e("react-dom"),s=n.interopDefault(a),c=e("@radix-ui/react-primitive");let u=/*#__PURE__*/(0,i.forwardRef)((e,t)=>{var r;let{container:n=null==globalThis?void 0:null===(r=globalThis.document)||void 0===r?void 0:r.body,...o}=e;return n?/*#__PURE__*/(0,s.default).createPortal(/*#__PURE__*/(0,i.createElement)(c.Primitive.div,(0,l.default)({},o,{ref:t})),n):null}),d=u},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","react-dom":"b8T3j","@radix-ui/react-primitive":"12EJa","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],hcPVs:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"usePrevious",()=>l);var o=e("react");function l(e){let t=(0,o.useRef)({value:e,previous:e});// We compare values before making an update to ensure that
// a change has been made. This ensures the previous value is
// persisted correctly between renders.
return(0,o.useMemo)(()=>(t.current.value!==e&&(t.current.previous=t.current.value,t.current.value=e),t.current.previous),[e])}},{react:"6uln9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"2C47u":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"VisuallyHidden",()=>s),n.export(r,"Root",()=>c);var o=e("@babel/runtime/helpers/esm/extends"),l=n.interopDefault(o),i=e("react"),a=e("@radix-ui/react-primitive");let s=/*#__PURE__*/(0,i.forwardRef)((e,t)=>/*#__PURE__*/(0,i.createElement)(a.Primitive.span,(0,l.default)({},e,{ref:t,style:{// See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal",...e.style}}))),c=s},{"@babel/runtime/helpers/esm/extends":"fW5l8",react:"6uln9","@radix-ui/react-primitive":"12EJa","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"4ksDn":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"hideOthers",()=>d),n.export(r,"inertOthers",()=>f),n.export(r,"supportsInert",()=>p),n.export(r,"suppressOthers",()=>m);var o=function(e){return"undefined"==typeof document?null:(Array.isArray(e)?e[0]:e).ownerDocument.body},l=new WeakMap,i=new WeakMap,a={},s=0,c=function(e){return e&&(e.host||c(e.parentNode))},u=function(e,t,r,n){var o=(Array.isArray(e)?e:[e]).map(function(e){if(t.contains(e))return e;var r=c(e);return r&&t.contains(r)?r:(console.error("aria-hidden",e,"in not contained inside",t,". Doing nothing"),null)}).filter(function(e){return!!e});a[r]||(a[r]=new WeakMap);var u=a[r],d=[],f=new Set,p=new Set(o),m=function(e){!e||f.has(e)||(f.add(e),m(e.parentNode))};o.forEach(m);var h=function(e){!e||p.has(e)||Array.prototype.forEach.call(e.children,function(e){if(f.has(e))h(e);else{var t=e.getAttribute(n),o=null!==t&&"false"!==t,a=(l.get(e)||0)+1,s=(u.get(e)||0)+1;l.set(e,a),u.set(e,s),d.push(e),1===a&&o&&i.set(e,!0),1===s&&e.setAttribute(r,"true"),o||e.setAttribute(n,"true")}})};return h(t),f.clear(),s++,function(){d.forEach(function(e){var t=l.get(e)-1,o=u.get(e)-1;l.set(e,t),u.set(e,o),t||(i.has(e)||e.removeAttribute(n),i.delete(e)),o||e.removeAttribute(r)}),--s||(// clear
l=new WeakMap,l=new WeakMap,i=new WeakMap,a={})}},d=function(e,t,r){void 0===r&&(r="data-aria-hidden");var n=Array.from(Array.isArray(e)?e:[e]),l=t||o(e);return l?(// we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
n.push.apply(n,Array.from(l.querySelectorAll("[aria-live]"))),u(n,l,r,"aria-hidden")):function(){return null}},f=function(e,t,r){void 0===r&&(r="data-inert-ed");var n=t||o(e);return n?u(e,n,r,"inert"):function(){return null}},p=function(){return"undefined"!=typeof HTMLElement&&HTMLElement.prototype.hasOwnProperty("inert")},m=function(e,t,r){return void 0===r&&(r="data-suppressed"),(p()?f:d)(e,t,r)}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"6X6Q6":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"RemoveScroll",()=>l.default);var o=e("./Combination"),l=n.interopDefault(o)},{"./Combination":"zwo4w","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],zwo4w:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r);var o=e("tslib"),l=e("react"),i=e("./UI"),a=e("./sidecar"),s=n.interopDefault(a),c=l.forwardRef(function(e,t){return l.createElement(i.RemoveScroll,(0,o.__assign)({},e,{ref:t,sideCar:s.default}))});c.classNames=i.RemoveScroll.classNames,r.default=c},{tslib:"gBS4y",react:"6uln9","./UI":"e3CpR","./sidecar":"4fJx7","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],gBS4y:[function(e,t,r){/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** *//* global Reflect, Promise, SuppressedError, Symbol */var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"__extends",()=>l),n.export(r,"__assign",()=>i),n.export(r,"__rest",()=>a),n.export(r,"__decorate",()=>s),n.export(r,"__param",()=>c),n.export(r,"__esDecorate",()=>u),n.export(r,"__runInitializers",()=>d),n.export(r,"__propKey",()=>f),n.export(r,"__setFunctionName",()=>p),n.export(r,"__metadata",()=>m),n.export(r,"__awaiter",()=>h),n.export(r,"__generator",()=>v),n.export(r,"__createBinding",()=>g),n.export(r,"__exportStar",()=>x),n.export(r,"__values",()=>y),n.export(r,"__read",()=>b),/** @deprecated */n.export(r,"__spread",()=>w),/** @deprecated */n.export(r,"__spreadArrays",()=>S),n.export(r,"__spreadArray",()=>E),n.export(r,"__await",()=>j),n.export(r,"__asyncGenerator",()=>C),n.export(r,"__asyncDelegator",()=>R),n.export(r,"__asyncValues",()=>P),n.export(r,"__makeTemplateObject",()=>_),n.export(r,"__importStar",()=>T),n.export(r,"__importDefault",()=>I),n.export(r,"__classPrivateFieldGet",()=>O),n.export(r,"__classPrivateFieldSet",()=>A),n.export(r,"__classPrivateFieldIn",()=>L),n.export(r,"__addDisposableResource",()=>N),n.export(r,"__disposeResources",()=>F);var o=function(e,t){return(o=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(e,t)};function l(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Class extends value "+String(t)+" is not a constructor or null");function r(){this.constructor=e}o(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}var i=function(){return(i=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)};function a(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&0>t.indexOf(n)&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var o=0,n=Object.getOwnPropertySymbols(e);o<n.length;o++)0>t.indexOf(n[o])&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]]);return r}function s(e,t,r,n){var o,l=arguments.length,i=l<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,t,r,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(i=(l<3?o(i):l>3?o(t,r,i):o(t,r))||i);return l>3&&i&&Object.defineProperty(t,r,i),i}function c(e,t){return function(r,n){t(r,n,e)}}function u(e,t,r,n,o,l){function i(e){if(void 0!==e&&"function"!=typeof e)throw TypeError("Function expected");return e}for(var a,s=n.kind,c="getter"===s?"get":"setter"===s?"set":"value",u=!t&&e?n.static?e:e.prototype:null,d=t||(u?Object.getOwnPropertyDescriptor(u,n.name):{}),f=!1,p=r.length-1;p>=0;p--){var m={};for(var h in n)m[h]="access"===h?{}:n[h];for(var h in n.access)m.access[h]=n.access[h];m.addInitializer=function(e){if(f)throw TypeError("Cannot add initializers after decoration has completed");l.push(i(e||null))};var v=(0,r[p])("accessor"===s?{get:d.get,set:d.set}:d[c],m);if("accessor"===s){if(void 0===v)continue;if(null===v||"object"!=typeof v)throw TypeError("Object expected");(a=i(v.get))&&(d.get=a),(a=i(v.set))&&(d.set=a),(a=i(v.init))&&o.unshift(a)}else(a=i(v))&&("field"===s?o.unshift(a):d[c]=a)}u&&Object.defineProperty(u,n.name,d),f=!0}function d(e,t,r){for(var n=arguments.length>2,o=0;o<t.length;o++)r=n?t[o].call(e,r):t[o].call(e);return n?r:void 0}function f(e){return"symbol"==typeof e?e:"".concat(e)}function p(e,t,r){return"symbol"==typeof t&&(t=t.description?"[".concat(t.description,"]"):""),Object.defineProperty(e,"name",{configurable:!0,value:r?"".concat(r," ",t):t})}function m(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}function h(e,t,r,n){return new(r||(r=Promise))(function(o,l){function i(e){try{s(n.next(e))}catch(e){l(e)}}function a(e){try{s(n.throw(e))}catch(e){l(e)}}function s(e){var t;e.done?o(e.value):((t=e.value)instanceof r?t:new r(function(e){e(t)})).then(i,a)}s((n=n.apply(e,t||[])).next())})}function v(e,t){var r,n,o,l,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return l={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(l[Symbol.iterator]=function(){return this}),l;function a(a){return function(s){return function(a){if(r)throw TypeError("Generator is already executing.");for(;l&&(l=0,a[0]&&(i=0)),i;)try{if(r=1,n&&(o=2&a[0]?n.return:a[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,a[1])).done)return o;switch(n=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,n=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(e){a=[6,e],n=0}finally{r=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var g=Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);(!o||("get"in o?!t.__esModule:o.writable||o.configurable))&&(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]};function x(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||g(t,e,r)}function y(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function b(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,o,l=r.call(e),i=[];try{for(;(void 0===t||t-- >0)&&!(n=l.next()).done;)i.push(n.value)}catch(e){o={error:e}}finally{try{n&&!n.done&&(r=l.return)&&r.call(l)}finally{if(o)throw o.error}}return i}function w(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(b(arguments[t]));return e}function S(){for(var e=0,t=0,r=arguments.length;t<r;t++)e+=arguments[t].length;for(var n=Array(e),o=0,t=0;t<r;t++)for(var l=arguments[t],i=0,a=l.length;i<a;i++,o++)n[o]=l[i];return n}function E(e,t,r){if(r||2==arguments.length)for(var n,o=0,l=t.length;o<l;o++)!n&&o in t||(n||(n=Array.prototype.slice.call(t,0,o)),n[o]=t[o]);return e.concat(n||Array.prototype.slice.call(t))}function j(e){return this instanceof j?(this.v=e,this):new j(e)}function C(e,t,r){if(!Symbol.asyncIterator)throw TypeError("Symbol.asyncIterator is not defined.");var n,o=r.apply(e,t||[]),l=[];return n={},i("next"),i("throw"),i("return"),n[Symbol.asyncIterator]=function(){return this},n;function i(e){o[e]&&(n[e]=function(t){return new Promise(function(r,n){l.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{var r;(r=o[e](t)).value instanceof j?Promise.resolve(r.value.v).then(s,c):u(l[0][2],r)}catch(e){u(l[0][3],e)}}function s(e){a("next",e)}function c(e){a("throw",e)}function u(e,t){e(t),l.shift(),l.length&&a(l[0][0],l[0][1])}}function R(e){var t,r;return t={},n("next"),n("throw",function(e){throw e}),n("return"),t[Symbol.iterator]=function(){return this},t;function n(n,o){t[n]=e[n]?function(t){return(r=!r)?{value:j(e[n](t)),done:!1}:o?o(t):t}:o}}function P(e){if(!Symbol.asyncIterator)throw TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e=y(e),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise(function(n,o){!function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)}(n,o,(t=e[r](t)).done,t.value)})}}}function _(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e}var k=Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t};function T(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&g(t,e,r);return k(t,e),t}function I(e){return e&&e.__esModule?e:{default:e}}function O(e,t,r,n){if("a"===r&&!n)throw TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)}function A(e,t,r,n,o){if("m"===n)throw TypeError("Private method is not writable");if("a"===n&&!o)throw TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!o:!t.has(e))throw TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?o.call(e,r):o?o.value=r:t.set(e,r),r}function L(e,t){if(null===t||"object"!=typeof t&&"function"!=typeof t)throw TypeError("Cannot use 'in' operator on non-object");return"function"==typeof e?t===e:e.has(t)}function N(e,t,r){if(null!=t){var n;if("object"!=typeof t&&"function"!=typeof t)throw TypeError("Object expected.");if(r){if(!Symbol.asyncDispose)throw TypeError("Symbol.asyncDispose is not defined.");n=t[Symbol.asyncDispose]}if(void 0===n){if(!Symbol.dispose)throw TypeError("Symbol.dispose is not defined.");n=t[Symbol.dispose]}if("function"!=typeof n)throw TypeError("Object not disposable.");e.stack.push({value:t,dispose:n,async:r})}else r&&e.stack.push({async:!0});return t}var D="function"==typeof SuppressedError?SuppressedError:function(e,t,r){var n=Error(r);return n.name="SuppressedError",n.error=e,n.suppressed=t,n};function F(e){function t(t){e.error=e.hasError?new D(t,e.error,"An error was suppressed during disposal."):t,e.hasError=!0}return function r(){for(;e.stack.length;){var n=e.stack.pop();try{var o=n.dispose&&n.dispose.call(n.value);if(n.async)return Promise.resolve(o).then(r,function(e){return t(e),r()})}catch(e){t(e)}}if(e.hasError)throw e.error}()}r.default={__extends:l,__assign:i,__rest:a,__decorate:s,__param:c,__metadata:m,__awaiter:h,__generator:v,__createBinding:g,__exportStar:x,__values:y,__read:b,__spread:w,__spreadArrays:S,__spreadArray:E,__await:j,__asyncGenerator:C,__asyncDelegator:R,__asyncValues:P,__makeTemplateObject:_,__importStar:T,__importDefault:I,__classPrivateFieldGet:O,__classPrivateFieldSet:A,__classPrivateFieldIn:L,__addDisposableResource:N,__disposeResources:F}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],e3CpR:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"RemoveScroll",()=>u);var o=e("tslib"),l=e("react"),i=e("react-remove-scroll-bar/constants"),a=e("use-callback-ref"),s=e("./medium"),c=function(){},u=l.forwardRef(function(e,t){var r=l.useRef(null),n=l.useState({onScrollCapture:c,onWheelCapture:c,onTouchMoveCapture:c}),i=n[0],u=n[1],d=e.forwardProps,f=e.children,p=e.className,m=e.removeScrollBar,h=e.enabled,v=e.shards,g=e.sideCar,x=e.noIsolation,y=e.inert,b=e.allowPinchZoom,w=e.as,S=void 0===w?"div":w,E=(0,o.__rest)(e,["forwardProps","children","className","removeScrollBar","enabled","shards","sideCar","noIsolation","inert","allowPinchZoom","as"]),j=(0,a.useMergeRefs)([r,t]),C=(0,o.__assign)((0,o.__assign)({},E),i);return l.createElement(l.Fragment,null,h&&l.createElement(g,{sideCar:s.effectCar,removeScrollBar:m,shards:v,noIsolation:x,inert:y,setCallbacks:u,allowPinchZoom:!!b,lockRef:r}),d?l.cloneElement(l.Children.only(f),(0,o.__assign)((0,o.__assign)({},C),{ref:j})):l.createElement(S,(0,o.__assign)({},C,{className:p,ref:j}),f))});u.defaultProps={enabled:!0,removeScrollBar:!0,inert:!1},u.classNames={fullWidth:i.fullWidthClassName,zeroRight:i.zeroRightClassName}},{tslib:"gBS4y",react:"6uln9","react-remove-scroll-bar/constants":"d1hBU","use-callback-ref":"98LI5","./medium":"1Cdo7","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],d1hBU:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"zeroRightClassName",()=>o),n.export(r,"fullWidthClassName",()=>l),n.export(r,"noScrollbarsClassName",()=>i),n.export(r,"removedBarSizeVariable",()=>a);var o="right-scroll-bar-position",l="width-before-scroll-bar",i="with-scroll-bars-hidden",a="--removed-body-scroll-bar-size"},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"98LI5":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"assignRef",()=>o.assignRef),// callback ref
n.export(r,"useCallbackRef",()=>l.useCallbackRef),n.export(r,"createCallbackRef",()=>i.createCallbackRef),// merge ref
n.export(r,"mergeRefs",()=>a.mergeRefs),n.export(r,"useMergeRefs",()=>s.useMergeRefs),// transform ref
n.export(r,"useTransformRef",()=>c.useTransformRef),n.export(r,"transformRef",()=>u.transformRef),// refToCallback
n.export(r,"refToCallback",()=>d.refToCallback),n.export(r,"useRefToCallback",()=>d.useRefToCallback);var o=e("./assignRef"),l=e("./useRef"),i=e("./createRef"),a=e("./mergeRef"),s=e("./useMergeRef"),c=e("./useTransformRef"),u=e("./transformRef"),d=e("./refToCallback")},{"./assignRef":!1,"./useRef":!1,"./createRef":!1,"./mergeRef":!1,"./useMergeRef":"iz8ib","./useTransformRef":!1,"./transformRef":!1,"./refToCallback":!1,"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"1RTwo":[function(e,t,r){/**
 * Assigns a value for a given ref, no matter of the ref format
 * @param {RefObject} ref - a callback function or ref object
 * @param value - a new value
 *
 * @see https://github.com/theKashey/use-callback-ref#assignref
 * @example
 * const refObject = useRef();
 * const refFn = (ref) => {....}
 *
 * assignRef(refObject, "refValue");
 * assignRef(refFn, "refValue");
 */var n=e("@parcel/transformer-js/src/esmodule-helpers.js");function o(e,t){return"function"==typeof e?e(t):e&&(e.current=t),e}n.defineInteropFlag(r),n.export(r,"assignRef",()=>o)},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"83aml":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),/**
 * creates a MutableRef with ref change callback
 * @param initialValue - initial ref value
 * @param {Function} callback - a callback to run when value changes
 *
 * @example
 * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
 * ref.current = 1;
 * // prints 0 -> 1
 *
 * @see https://reactjs.org/docs/hooks-reference.html#useref
 * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
 * @returns {MutableRefObject}
 */n.export(r,"useCallbackRef",()=>l);var o=e("react");function l(e,t){var r=(0,o.useState)(function(){return{// value
value:e,// last callback
callback:t,// "memoized" public interface
facade:{get current(){return r.value},set current(value){var n=r.value;n!==value&&(r.value=value,r.callback(value,n))}}}})[0];return(// update callback
r.callback=t,r.facade)}},{react:"6uln9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],iz8ib:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),/**
 * Merges two or more refs together providing a single interface to set their value
 * @param {RefObject|Ref} refs
 * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
 *
 * @see {@link mergeRefs} a version without buit-in memoization
 * @see https://github.com/theKashey/use-callback-ref#usemergerefs
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const ownRef = useRef();
 *   const domRef = useMergeRefs([ref, ownRef]); // ðŸ‘ˆ merge together
 *   return <div ref={domRef}>...</div>
 * }
 */n.export(r,"useMergeRefs",()=>i);var o=e("./assignRef"),l=e("./useRef");function i(e,t){return(0,l.useCallbackRef)(t||null,function(t){return e.forEach(function(e){return(0,o.assignRef)(e,t)})})}},{"./assignRef":"1RTwo","./useRef":"83aml","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"1Cdo7":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"effectCar",()=>o);var o=(0,e("use-sidecar").createSidecarMedium)()},{"use-sidecar":"fXhf9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],fXhf9:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"sidecar",()=>o.sidecar),n.export(r,"useSidecar",()=>l.useSidecar),n.export(r,"setConfig",()=>i.setConfig),n.export(r,"createMedium",()=>a.createMedium),n.export(r,"createSidecarMedium",()=>a.createSidecarMedium),n.export(r,"renderCar",()=>s.renderCar),n.export(r,"exportSidecar",()=>c.exportSidecar);var o=e("./hoc"),l=e("./hook"),i=e("./config"),a=e("./medium"),s=e("./renderProp"),c=e("./exports")},{"./hoc":!1,"./hook":!1,"./config":!1,"./medium":"gA2xZ","./renderProp":!1,"./exports":"eV1g6","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],gA2xZ:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"createMedium",()=>a),// eslint-disable-next-line @typescript-eslint/ban-types
n.export(r,"createSidecarMedium",()=>s);var o=e("tslib");function l(e){return e}function i(e,t){void 0===t&&(t=l);var r=[],n=!1;return{read:function(){if(n)throw Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");return r.length?r[r.length-1]:e},useMedium:function(e){var o=t(e,n);return r.push(o),function(){r=r.filter(function(e){return e!==o})}},assignSyncMedium:function(e){for(n=!0;r.length;){var t=r;r=[],t.forEach(e)}r={push:function(t){return e(t)},filter:function(){return r}}},assignMedium:function(e){n=!0;var t=[];if(r.length){var o=r;r=[],o.forEach(e),t=r}var l=function(){var r=t;t=[],r.forEach(e)},i=function(){return Promise.resolve().then(l)};i(),r={push:function(e){t.push(e),i()},filter:function(e){return t=t.filter(e),r}}}}}function a(e,t){return void 0===t&&(t=l),i(e,t)}function s(e){void 0===e&&(e={});var t=i(null);return t.options=(0,o.__assign)({async:!0,ssr:!1},e),t}},{tslib:"gBS4y","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],eV1g6:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"exportSidecar",()=>a);var o=e("tslib"),l=e("react"),i=function(e){var t=e.sideCar,r=(0,o.__rest)(e,["sideCar"]);if(!t)throw Error("Sidecar: please provide `sideCar` property to import the right car");var n=t.read();if(!n)throw Error("Sidecar medium not found");return l.createElement(n,(0,o.__assign)({},r))};function a(e,t){return e.useMedium(t),i}i.isSideCarExport=!0},{tslib:"gBS4y",react:"6uln9","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"4fJx7":[function(e,t,r){e("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(r);var n=e("use-sidecar"),o=e("./SideEffect"),l=e("./medium");r.default=(0,n.exportSidecar)(l.effectCar,o.RemoveScrollSideCar)},{"use-sidecar":"fXhf9","./SideEffect":"iGVbN","./medium":"1Cdo7","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],iGVbN:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"getTouchXY",()=>u),n.export(r,"getDeltaXY",()=>d),n.export(r,"RemoveScrollSideCar",()=>h);var o=e("tslib"),l=e("react"),i=e("react-remove-scroll-bar"),a=e("react-style-singleton"),s=e("./aggresiveCapture"),c=e("./handleScroll"),u=function(e){return"changedTouches"in e?[e.changedTouches[0].clientX,e.changedTouches[0].clientY]:[0,0]},d=function(e){return[e.deltaX,e.deltaY]},f=function(e){return e&&"current"in e?e.current:e},p=0,m=[];function h(e){var t=l.useRef([]),r=l.useRef([0,0]),n=l.useRef(),h=l.useState(p++)[0],v=l.useState(function(){return(0,a.styleSingleton)()})[0],g=l.useRef(e);l.useEffect(function(){g.current=e},[e]),l.useEffect(function(){if(e.inert){document.body.classList.add("block-interactivity-".concat(h));var t=(0,o.__spreadArray)([e.lockRef.current],(e.shards||[]).map(f),!0).filter(Boolean);return t.forEach(function(e){return e.classList.add("allow-interactivity-".concat(h))}),function(){document.body.classList.remove("block-interactivity-".concat(h)),t.forEach(function(e){return e.classList.remove("allow-interactivity-".concat(h))})}}},[e.inert,e.lockRef.current,e.shards]);var x=l.useCallback(function(e,t){if("touches"in e&&2===e.touches.length)return!g.current.allowPinchZoom;var o,l=u(e),i=r.current,a="deltaX"in e?e.deltaX:i[0]-l[0],s="deltaY"in e?e.deltaY:i[1]-l[1],d=e.target,f=Math.abs(a)>Math.abs(s)?"h":"v";// allow horizontal touch move on Range inputs. They will not cause any scroll
if("touches"in e&&"h"===f&&"range"===d.type)return!1;var p=(0,c.locationCouldBeScrolled)(f,d);if(!p)return!0;if(p?o=f:(o="v"===f?"h":"v",p=(0,c.locationCouldBeScrolled)(f,d)),!p)return!1;if(!n.current&&"changedTouches"in e&&(a||s)&&(n.current=o),!o)return!0;var m=n.current||o;return(0,c.handleScroll)(m,t,e,"h"===m?a:s,!0)},[]),y=l.useCallback(function(e){if(m.length&&m[m.length-1]===v){var r="deltaY"in e?d(e):u(e),n=t.current.filter(function(t){var n;return t.name===e.type&&t.target===e.target&&(n=t.delta)[0]===r[0]&&n[1]===r[1]})[0];// self event, and should be canceled
if(n&&n.should){e.cancelable&&e.preventDefault();return}// outside or shard event
if(!n){var o=(g.current.shards||[]).map(f).filter(Boolean).filter(function(t){return t.contains(e.target)});(o.length>0?x(e,o[0]):!g.current.noIsolation)&&e.cancelable&&e.preventDefault()}}},[]),b=l.useCallback(function(e,r,n,o){var l={name:e,delta:r,target:n,should:o};t.current.push(l),setTimeout(function(){t.current=t.current.filter(function(e){return e!==l})},1)},[]),w=l.useCallback(function(e){r.current=u(e),n.current=void 0},[]),S=l.useCallback(function(t){b(t.type,d(t),t.target,x(t,e.lockRef.current))},[]),E=l.useCallback(function(t){b(t.type,u(t),t.target,x(t,e.lockRef.current))},[]);l.useEffect(function(){return m.push(v),e.setCallbacks({onScrollCapture:S,onWheelCapture:S,onTouchMoveCapture:E}),document.addEventListener("wheel",y,s.nonPassive),document.addEventListener("touchmove",y,s.nonPassive),document.addEventListener("touchstart",w,s.nonPassive),function(){m=m.filter(function(e){return e!==v}),document.removeEventListener("wheel",y,s.nonPassive),document.removeEventListener("touchmove",y,s.nonPassive),document.removeEventListener("touchstart",w,s.nonPassive)}},[]);var j=e.removeScrollBar,C=e.inert;return l.createElement(l.Fragment,null,C?l.createElement(v,{styles:"\n  .block-interactivity-".concat(h," {pointer-events: none;}\n  .allow-interactivity-").concat(h," {pointer-events: all;}\n")}):null,j?l.createElement(i.RemoveScrollBar,{gapMode:"margin"}):null)}},{tslib:"gBS4y",react:"6uln9","react-remove-scroll-bar":"avmZA","react-style-singleton":"k67VS","./aggresiveCapture":"6W2jc","./handleScroll":"apzMm","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],avmZA:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"RemoveScrollBar",()=>o.RemoveScrollBar),n.export(r,"zeroRightClassName",()=>l.zeroRightClassName),n.export(r,"fullWidthClassName",()=>l.fullWidthClassName),n.export(r,"noScrollbarsClassName",()=>l.noScrollbarsClassName),n.export(r,"removedBarSizeVariable",()=>l.removedBarSizeVariable),n.export(r,"getGapWidth",()=>i.getGapWidth);var o=e("./component"),l=e("./constants"),i=e("./utils")},{"./component":"4VwpI","./constants":"d1hBU","./utils":"iJCCt","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"4VwpI":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"RemoveScrollBar",()=>u);var o=e("react"),l=e("react-style-singleton"),i=e("./constants"),a=e("./utils"),s=(0,l.styleSingleton)(),c=function(e,t,r,n){var o=e.left,l=e.top,a=e.right,s=e.gap;return void 0===r&&(r="margin"),"\n  .".concat(i.noScrollbarsClassName," {\n   overflow: hidden ").concat(n,";\n   padding-right: ").concat(s,"px ").concat(n,";\n  }\n  body {\n    overflow: hidden ").concat(n,";\n    overscroll-behavior: contain;\n    ").concat([t&&"position: relative ".concat(n,";"),"margin"===r&&"\n    padding-left: ".concat(o,"px;\n    padding-top: ").concat(l,"px;\n    padding-right: ").concat(a,"px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(s,"px ").concat(n,";\n    "),"padding"===r&&"padding-right: ".concat(s,"px ").concat(n,";")].filter(Boolean).join(""),"\n  }\n  \n  .").concat(i.zeroRightClassName," {\n    right: ").concat(s,"px ").concat(n,";\n  }\n  \n  .").concat(i.fullWidthClassName," {\n    margin-right: ").concat(s,"px ").concat(n,";\n  }\n  \n  .").concat(i.zeroRightClassName," .").concat(i.zeroRightClassName," {\n    right: 0 ").concat(n,";\n  }\n  \n  .").concat(i.fullWidthClassName," .").concat(i.fullWidthClassName," {\n    margin-right: 0 ").concat(n,";\n  }\n  \n  body {\n    ").concat(i.removedBarSizeVariable,": ").concat(s,"px;\n  }\n")},u=function(e){var t=e.noRelative,r=e.noImportant,n=e.gapMode,l=void 0===n?"margin":n,i=o.useMemo(function(){return(0,a.getGapWidth)(l)},[l]);return o.createElement(s,{styles:c(i,!t,l,r?"":"!important")})}},{react:"6uln9","react-style-singleton":"k67VS","./constants":"d1hBU","./utils":"iJCCt","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],k67VS:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"styleSingleton",()=>o.styleSingleton),n.export(r,"stylesheetSingleton",()=>l.stylesheetSingleton),n.export(r,"styleHookSingleton",()=>i.styleHookSingleton);var o=e("./component"),l=e("./singleton"),i=e("./hook")},{"./component":"dl6e1","./singleton":"aQqP2","./hook":"8XHLc","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],dl6e1:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"styleSingleton",()=>l);var o=e("./hook"),l=function(){var e=(0,o.styleHookSingleton)();return function(t){return e(t.styles,t.dynamic),null}}},{"./hook":"8XHLc","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"8XHLc":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"styleHookSingleton",()=>i);var o=e("react"),l=e("./singleton"),i=function(){var e=(0,l.stylesheetSingleton)();return function(t,r){o.useEffect(function(){return e.add(t),function(){e.remove()}},[t&&r])}}},{react:"6uln9","./singleton":"aQqP2","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],aQqP2:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"stylesheetSingleton",()=>l);var o=e("get-nonce"),l=function(){var e=0,t=null;return{add:function(r){if(0==e&&(t=function(){if(!document)return null;var e=document.createElement("style");e.type="text/css";var t=(0,o.getNonce)();return t&&e.setAttribute("nonce",t),e}())){var n,l;(n=t).styleSheet?n.styleSheet.cssText=r:n.appendChild(document.createTextNode(r)),l=t,(document.head||document.getElementsByTagName("head")[0]).appendChild(l)}e++},remove:function(){--e||!t||(t.parentNode&&t.parentNode.removeChild(t),t=null)}}}},{"get-nonce":"aSpXt","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],aSpXt:[function(e,t,r){var n,o=e("@parcel/transformer-js/src/esmodule-helpers.js");o.defineInteropFlag(r),o.export(r,"setNonce",()=>l),o.export(r,"getNonce",()=>i);var l=function(e){n=e},i=function(){return n||("undefined"!=typeof __webpack_nonce__?__webpack_nonce__:void 0)}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],iJCCt:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"zeroGap",()=>o),n.export(r,"getGapWidth",()=>a);var o={left:0,top:0,right:0,gap:0},l=function(e){return parseInt(e||"",10)||0},i=function(e){var t=window.getComputedStyle(document.body),r=t["padding"===e?"paddingLeft":"marginLeft"],n=t["padding"===e?"paddingTop":"marginTop"],o=t["padding"===e?"paddingRight":"marginRight"];return[l(r),l(n),l(o)]},a=function(e){if(void 0===e&&(e="margin"),"undefined"==typeof window)return o;var t=i(e),r=document.documentElement.clientWidth,n=window.innerWidth;return{left:t[0],top:t[1],right:t[2],gap:Math.max(0,n-r+t[2]-t[0])}}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],"6W2jc":[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"nonPassive",()=>i);var o=!1;if("undefined"!=typeof window)try{var l=Object.defineProperty({},"passive",{get:function(){return o=!0,!0}});// @ts-ignore
window.addEventListener("test",l,l),// @ts-ignore
window.removeEventListener("test",l,l)}catch(e){o=!1}var i=!!o&&{passive:!1}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],apzMm:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"locationCouldBeScrolled",()=>l),n.export(r,"handleScroll",()=>s);var o=function(e,t){var r=window.getComputedStyle(e);return"hidden"!==r[t]&&// contains scroll inside self
!(r.overflowY===r.overflowX&&"TEXTAREA"!==e.tagName&&"visible"===r[t])},l=function(e,t){var r=t;do{if("undefined"!=typeof ShadowRoot&&r instanceof ShadowRoot&&(r=r.host),i(e,r)){var n=a(e,r);if(n[1]>n[2])return!0}r=r.parentNode}while(r&&r!==document.body)return!1},i=function(e,t){return"v"===e?o(t,"overflowY"):o(t,"overflowX")},a=function(e,t){return"v"===e?[t.scrollTop,t.scrollHeight,t.clientHeight]:[t.scrollLeft,t.scrollWidth,t.clientWidth]},s=function(e,t,r,n,o){var l,s=(l=window.getComputedStyle(t).direction,"h"===e&&"rtl"===l?-1:1),c=s*n,u=r.target,d=t.contains(u),f=!1,p=c>0,m=0,h=0;do{var v=a(e,u),g=v[0],x=v[1]-v[2]-s*g;(g||x)&&i(e,u)&&(m+=x,h+=g),u=u.parentNode}while(!d&&u!==document.body||// self content
d&&(t.contains(u)||t===u))return p&&(o&&0===m||!o&&c>m)?f=!0:!p&&(o&&0===h||!o&&-c>h)&&(f=!0),f}},{"@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],dRKtt:[function(e,t,r){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"Icon",()=>c);var o=e("react/jsx-runtime"),l=e("classnames"),i=n.interopDefault(l),a=e("./shapes.svg"),s=n.interopDefault(a);function c({name:e,flip:t,rotate:r,className:n,size:l}){let a;return r?a=`rotate(${r}deg)`:t&&(a="rotateY(180deg)"),/*#__PURE__*/(0,o.jsx)("svg",{preserveAspectRatio:"xMidYMid meet",style:{width:l,height:l,transform:a},className:(0,i.default)("icon",`icon-${e}`,n),children:/*#__PURE__*/(0,o.jsx)("use",{xlinkHref:`${s.default}#${e}`})})}},{"react/jsx-runtime":"gaGEj",classnames:"hVGzI","./shapes.svg":"kGwTi","@parcel/transformer-js/src/esmodule-helpers.js":"k3151"}],kGwTi:[function(e,t,r){t.exports=e("ffe59b27c4dba66f").getBundleURL("6xHUA")+e("7024c694bf99fee0").resolve("boPw9")},{ffe59b27c4dba66f:"c7Tr5","7024c694bf99fee0":"fyJL2"}]},[],null,"parcelRequire2d1d")//# sourceMappingURL=ProductList.f43b7828.js.map
;
//# sourceMappingURL=ProductList.f43b7828.js.map
